/*
   Android Session Activity

   Copyright 2013 Thincast Technologies GmbH, Author: Martin Fleisz

   This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
   If a copy of the MPL was not distributed with this file, You can obtain one at
   http://mozilla.org/MPL/2.0/.
 */

package com.freerdp.freerdpcore.presentation;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.app.UiModeManager;
import android.content.BroadcastReceiver;
import android.content.ComponentCallbacks2;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.inputmethodservice.Keyboard;
import android.inputmethodservice.KeyboardView;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.graphics.Color;
import android.graphics.Typeface;
import android.text.InputType;
import android.text.SpannableString;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.view.inputmethod.InputMethodSubtype;
import android.widget.EditText;
import android.widget.Toast;
import android.widget.ZoomControls;

import com.freerdp.freerdpcore.R;
import com.freerdp.freerdpcore.application.GlobalApp;
import com.freerdp.freerdpcore.application.SessionState;
import com.freerdp.freerdpcore.domain.BookmarkBase;
import com.freerdp.freerdpcore.domain.ConnectionReference;
import com.freerdp.freerdpcore.domain.ManualBookmark;
import com.freerdp.freerdpcore.services.LibFreeRDP;
import com.freerdp.freerdpcore.services.RdpAudioService;
import com.freerdp.freerdpcore.utils.ClipboardManagerProxy;
import com.freerdp.freerdpcore.utils.KeyboardMapper;
import com.freerdp.freerdpcore.utils.Mouse;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class SessionActivity extends AppCompatActivity
    implements LibFreeRDP.UIEventListener, KeyboardView.OnKeyboardActionListener,
               ScrollView2D.ScrollView2DListener, KeyboardMapper.KeyProcessingListener,
               SessionView.SessionViewListener, TouchPointerView.TouchPointerListener,
               ClipboardManagerProxy.OnClipboardChangedListener, ComponentCallbacks2
{
	public static final String PARAM_CONNECTION_REFERENCE = "conRef";
	public static final String PARAM_INSTANCE = "instance";
	private static final float ZOOMING_STEP = 0.5f;
	private static final int ZOOMCONTROLS_AUTOHIDE_TIMEOUT = 4000;
	// timeout between subsequent scrolling requests when the touch-pointer is
	// at the edge of the session view
	private static final int SCROLLING_TIMEOUT = 50;
	private static final int SCROLLING_DISTANCE = 20;
	private static final String TAG = "FreeRDP.SessionActivity";
	// variables for delayed move event sending
	private static final int MAX_DISCARDED_MOVE_EVENTS = 3;
	private static final int SEND_MOVE_EVENT_TIMEOUT = 150;
	private Bitmap bitmap;
	private SessionState session;
	private SessionView sessionView;
	private TouchPointerView touchPointerView;
	private ProgressDialog progressDialog;
	private KeyboardView keyboardView;
	private KeyboardView modifiersKeyboardView;
	private ZoomControls zoomControls;
	private KeyboardMapper keyboardMapper;

	// ALT key state tracking
	private boolean isAltKeyActive = false;
	private MenuItem altKeyMenuItem = null;

	// Default zoom flag - only set once on first connection
	private boolean hasSetDefaultZoom = false;

	private Keyboard specialkeysKeyboard;
	private Keyboard numpadKeyboard;
	private Keyboard cursorKeyboard;
	private Keyboard modifiersKeyboard;

	private AlertDialog dlgVerifyCertificate;
	private AlertDialog dlgUserCredentials;
	private View userCredView;

	private UIHandler uiHandler;

	private int screen_width;
	private int screen_height;

	private boolean connectCancelledByUser = false;
	private boolean sessionRunning = false;
	private boolean manualDisconnect = false; // Flag for manual disconnect (no auto-reconnect)
	private boolean toggleMouseButtons = false;

	// WakeLock for background connection stability (fallback if foreground service fails)
	private android.os.PowerManager.WakeLock wakeLock = null;

	// Network state receiver (dynamic registration for active sessions only)
	private com.freerdp.freerdpcore.application.NetworkStateReceiver networkStateReceiver = null;
	private boolean isNetworkReceiverRegistered = false;

	private LibFreeRDPBroadcastReceiver libFreeRDPBroadcastReceiver;
	private BroadcastReceiver memoryPressureReceiver;
	private ScrollView2D scrollView;
	// keyboard visibility flags
	private boolean sysKeyboardVisible = false;
	private boolean extKeyboardVisible = false;
	private int discardedMoveEvents = 0;
	private ClipboardManagerProxy mClipboardManager;
	private boolean callbackDialogResult;
	View mDecor;
	
	// Memory pressure state tracking
	private boolean isInMemoryCriticalMode = false;

	private void createDialogs()
	{
		// build verify certificate dialog
		dlgVerifyCertificate =
		    new AlertDialog.Builder(this)
		        .setTitle(R.string.dlg_title_verify_certificate)
		        .setPositiveButton(android.R.string.yes,
		                           new DialogInterface.OnClickListener() {
			                           @Override
			                           public void onClick(DialogInterface dialog, int which)
			                           {
				                           callbackDialogResult = true;
				                           synchronized (dialog)
				                           {
					                           dialog.notify();
				                           }
			                           }
		                           })
		        .setNegativeButton(android.R.string.no,
		                           new DialogInterface.OnClickListener() {
			                           @Override
			                           public void onClick(DialogInterface dialog, int which)
			                           {
				                           callbackDialogResult = false;
				                           connectCancelledByUser = true;
				                           synchronized (dialog)
				                           {
					                           dialog.notify();
				                           }
			                           }
		                           })
		        .setCancelable(false)
		        .create();

		// build the dialog
		userCredView = getLayoutInflater().inflate(R.layout.credentials, null, true);
		dlgUserCredentials =
		    new AlertDialog.Builder(this)
		        .setView(userCredView)
		        .setTitle(R.string.dlg_title_credentials)
		        .setPositiveButton(android.R.string.ok,
		                           new DialogInterface.OnClickListener() {
			                           @Override
			                           public void onClick(DialogInterface dialog, int which)
			                           {
				                           callbackDialogResult = true;
				                           synchronized (dialog)
				                           {
					                           dialog.notify();
				                           }
			                           }
		                           })
		        .setNegativeButton(android.R.string.cancel,
		                           new DialogInterface.OnClickListener() {
			                           @Override
			                           public void onClick(DialogInterface dialog, int which)
			                           {
				                           callbackDialogResult = false;
				                           connectCancelledByUser = true;
				                           synchronized (dialog)
				                           {
					                           dialog.notify();
				                           }
			                           }
		                           })
		        .setCancelable(false)
		        .create();
	}

	private boolean hasHardwareMenuButton()
	{
		if (Build.VERSION.SDK_INT <= 10)
			return true;

		if (Build.VERSION.SDK_INT >= 14)
		{
			boolean rc = false;
			final ViewConfiguration cfg = ViewConfiguration.get(this);

			return cfg.hasPermanentMenuKey();
		}

		return false;
	}

	@Override public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);

	// Initialize default zoom flag
	hasSetDefaultZoom = false;

	// 设置状态栏为半透明（始终显示，不隐藏）
	if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
		getWindow().setStatusBarColor(0x40000000); // 25%透明度的黑色
	}

	this.setContentView(R.layout.session);
		if (hasHardwareMenuButton() || ApplicationSettingsActivity.getHideActionBar(this))
		{
			this.getSupportActionBar().hide();
		}
		else
		{
			this.getSupportActionBar().show();
			// Hide ActionBar title text (remove "aFreeRDP" text)
			this.getSupportActionBar().setDisplayShowTitleEnabled(false);
		}

	Log.v(TAG, "Session.onCreate");

	// 检测自动恢复启动（静默处理，不打扰用户）
	if (getIntent() != null && getIntent().getBooleanExtra("auto_recovery", false)) {
		int restartCount = getIntent().getIntExtra("restart_count", 0);
		Log.i(TAG, "⚡ Activity launched by auto-recovery (restart: " + restartCount + ")");
		// 不显示 Toast，静默恢复
	}

	// ATTENTION: We use the onGlobalLayout notification to start our
	// session.
		// This is because only then we can know the exact size of our session
		// when using fit screen
		// accounting for any status bars etc. that Android might throws on us.
		// A bit weird looking
		// but this is the only way ...
		final View activityRootView = findViewById(R.id.session_root_view);
		activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(
		    new OnGlobalLayoutListener() {
			    @Override public void onGlobalLayout()
			    {
				    screen_width = activityRootView.getWidth();
				    screen_height = activityRootView.getHeight();

				    // start session
				    if (!sessionRunning && getIntent() != null)
				    {
					    processIntent(getIntent());
					    sessionRunning = true;
				    }
			    }
		    });

		sessionView = findViewById(R.id.sessionView);
		sessionView.setScaleGestureDetector(
		    new ScaleGestureDetector(this, new PinchZoomListener()));
		sessionView.setSessionViewListener(this);
		sessionView.requestFocus();

		touchPointerView = findViewById(R.id.touchPointerView);
		touchPointerView.setTouchPointerListener(this);
		touchPointerView.setSessionView(sessionView);

		keyboardMapper = new KeyboardMapper();
		keyboardMapper.init(this);
		keyboardMapper.reset(this);

		modifiersKeyboard = new Keyboard(getApplicationContext(), R.xml.modifiers_keyboard);
		specialkeysKeyboard = new Keyboard(getApplicationContext(), R.xml.specialkeys_keyboard);
		numpadKeyboard = new Keyboard(getApplicationContext(), R.xml.numpad_keyboard);
		cursorKeyboard = new Keyboard(getApplicationContext(), R.xml.cursor_keyboard);

		// hide keyboard below the sessionView
		keyboardView = findViewById(R.id.extended_keyboard);
		keyboardView.setKeyboard(specialkeysKeyboard);
		keyboardView.setOnKeyboardActionListener(this);

		modifiersKeyboardView = findViewById(R.id.extended_keyboard_header);
		modifiersKeyboardView.setKeyboard(modifiersKeyboard);
		modifiersKeyboardView.setOnKeyboardActionListener(this);

		scrollView = findViewById(R.id.sessionScrollView);
		scrollView.setScrollViewListener(this);
		uiHandler = new UIHandler();
		libFreeRDPBroadcastReceiver = new LibFreeRDPBroadcastReceiver();

		zoomControls = findViewById(R.id.zoomControls);
		zoomControls.hide();
		zoomControls.setOnZoomInClickListener(new View.OnClickListener() {
			@Override public void onClick(View v)
			{
				resetZoomControlsAutoHideTimeout();
				zoomControls.setIsZoomInEnabled(sessionView.zoomIn(ZOOMING_STEP));
				zoomControls.setIsZoomOutEnabled(true);
			}
		});
		zoomControls.setOnZoomOutClickListener(new View.OnClickListener() {
			@Override public void onClick(View v)
			{
				resetZoomControlsAutoHideTimeout();
				zoomControls.setIsZoomOutEnabled(sessionView.zoomOut(ZOOMING_STEP));
				zoomControls.setIsZoomInEnabled(true);
			}
		});

		toggleMouseButtons = false;

		createDialogs();

		// register freerdp events broadcast receiver
		IntentFilter filter = new IntentFilter();
		filter.addAction(GlobalApp.ACTION_EVENT_FREERDP);
		registerReceiver(libFreeRDPBroadcastReceiver, filter);

		// register memory pressure broadcast receiver
		memoryPressureReceiver = new BroadcastReceiver()
		{
			@Override
			public void onReceive(Context context, Intent intent)
			{
				String level = intent.getStringExtra("level");
				long instance = intent.getLongExtra("instance", -1);
				
				if (session != null && session.getInstance() == instance)
				{
					handleMemoryPressure(level);
				}
			}
		};
		IntentFilter memoryFilter = new IntentFilter("com.freerdp.MEMORY_PRESSURE");
		registerReceiver(memoryPressureReceiver, memoryFilter);

		mClipboardManager = ClipboardManagerProxy.getClipboardManager(this);
		mClipboardManager.addClipboardChangedListener(this);

	mDecor = getWindow().getDecorView();
	// 设置布局延伸到状态栏和导航栏下方，但保持它们始终可见
	mDecor.setSystemUiVisibility(
	    View.SYSTEM_UI_FLAG_LAYOUT_STABLE |
	    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |
	    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
	);
	
	// 设置半透明导航栏和状态栏（黑色半透明），始终显示
	if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
		getWindow().setNavigationBarColor(0x40000000); // 25%透明度的黑色
		getWindow().setStatusBarColor(0x40000000); // 25%透明度的黑色
	}
}

	@Override public void onWindowFocusChanged(boolean hasFocus)
	{
		super.onWindowFocusChanged(hasFocus);
		mClipboardManager.getPrimaryClipManually();
	}

	@Override
	protected void onNewIntent(Intent intent) {
		super.onNewIntent(intent);
		setIntent(intent);
		
		// 检测自动恢复启动（静默处理，不打扰用户）
		if (intent.getBooleanExtra("auto_recovery", false)) {
			int restartCount = intent.getIntExtra("restart_count", 0);
			Log.i(TAG, "⚡ Activity brought to front by auto-recovery (restart: " + restartCount + ")");
			// 不显示 Toast，静默恢复
		}
	}

	@Override protected void onStart()
	{
		super.onStart();
		Log.v(TAG, "Session.onStart");
	}

	@Override protected void onRestart()
	{
		super.onRestart();
		Log.v(TAG, "Session.onRestart");
	}

	@Override protected void onResume()
	{
		super.onResume();
		Log.v(TAG, "Session.onResume");
		
		// Exit memory critical mode
		isInMemoryCriticalMode = false;
		
		// Reset ALT key state when returning from lock screen
		if (isAltKeyActive) {
			isAltKeyActive = false;
			updateAltKeyIcon(false);
			// Release ALT key if it was pressed (using VK_LMENU)
			final int VK_LMENU = 0xA4;
			processVirtualKey(VK_LMENU, false);
			Log.d(TAG, "ALT key reset on resume (VK_LMENU released, screen unlocked)");
		}
		
		// Hide touch pointer when screen unlocks (any time)
		if (touchPointerView != null && touchPointerView.getVisibility() == View.VISIBLE) {
			touchPointerView.setVisibility(View.INVISIBLE);
			sessionView.setTouchPointerPadding(0, 0);
			Log.d(TAG, "Touch pointer hidden on resume (screen unlocked)");
		}
		
		// Hide keyboards when screen unlocks (any time)
		if (sysKeyboardVisible || extKeyboardVisible) {
			showKeyboard(false, false);
			Log.d(TAG, "Keyboards hidden on resume (screen unlocked)");
		}
		
	// Stop background keepalive (if any)
	stopBackgroundKeepalive();
	
	// Release WakeLock when returning to foreground
	releaseWakeLock();
	
	// Stop foreground service when returning to foreground
	RdpAudioService.stop(this);
	Log.i(TAG, "Foreground service stopped (app in foreground)");
	
	// Check if we need to recover background service state (service was killed)
	// This handles the case where system killed the app/service while in background
	if (!isInForeground && sessionRunning && !RdpAudioService.isRunning()) {
		Log.w(TAG, "⚠️ Service was killed while in background, attempting recovery");
		try {
			RdpAudioService.start(this);
			if (session != null) {
				startBackgroundKeepalive(session.getInstance());
			}
			// If service still fails, use WakeLock
			new android.os.Handler().postDelayed(new Runnable() {
				@Override
				public void run() {
					if (!RdpAudioService.isRunning()) {
						Log.e(TAG, "⚠️ Service recovery failed, using WakeLock");
						acquireWakeLock();
					}
				}
			}, 500);
		} catch (Exception e) {
			Log.e(TAG, "Failed to recover background service", e);
			acquireWakeLock();
		}
	}
	
// Resume graphics updates
isInForeground = true;
	serverUpdateReceived = false;
	lastServerUpdateTime = 0;
	
	// Only enable graphics if session is fully connected
	if (session != null && sessionRunning && scrollView != null && scrollView.getChildCount() > 0) {
		
		// ✅ Restore SessionView visibility IMMEDIATELY (show old frame instantly)
		if (sessionView != null) {
			sessionView.setVisibility(View.VISIBLE);
			Log.i(TAG, "[Layer 0/6] SessionView visible (0ms) - old frame displayed");
		}
		
		// ✅ Show default cursor immediately (avoid blank cursor)
		if (sessionView != null) {
			sessionView.showDefaultCursor();
			Log.i(TAG, "[Layer 0/6] Default cursor shown (0ms)");
		}
		
		// ✅ Force full screen refresh (ensure complete frame)
		if (sessionView != null && bitmap != null) {
			sessionView.addInvalidRegion(new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()));
			Log.i(TAG, "[Layer 0/6] Full screen refresh queued (0ms)");
		}
		
		// === Layer 1: Enable decoding IMMEDIATELY (0ms) - RDP will auto-push updates ===
		try {
			LibFreeRDP.setClientDecoding(session.getInstance(), true);
			Log.i(TAG, "[Layer 1/6] Graphics decoding enabled (0ms)");
		} catch (Exception e) {
			Log.w(TAG, "Failed to enable graphics decoding", e);
		}
		
		// === Layer 2: View refresh IMMEDIATELY (0ms) - trigger redraw ===
		if (sessionView != null) {
			sessionView.invalidate();
			Log.i(TAG, "[Layer 2/6] View invalidated (0ms)");
		}
		
		// === Layer 3: Bitmap refresh (50ms) - display server-pushed data ===
		uiHandler.postDelayed(new Runnable() {
			@Override
			public void run() {
				if (isFinishing() || isDestroyed() || serverUpdateReceived) return;
				
				if (sessionView != null && bitmap != null) {
					sessionView.addInvalidRegion(new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()));
					uiHandler.sendEmptyMessage(UIHandler.REFRESH_SESSIONVIEW);
					Log.d(TAG, "[Layer 3/6] Bitmap refresh at 50ms");
				}
			}
		}, 50);
		
		// === Layer 4: Bitmap refresh (300ms) - network delay recovery ===
		uiHandler.postDelayed(new Runnable() {
			@Override
			public void run() {
				if (isFinishing() || isDestroyed() || serverUpdateReceived) return;
				
				if (sessionView != null && bitmap != null) {
					sessionView.addInvalidRegion(new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()));
					uiHandler.sendEmptyMessage(UIHandler.REFRESH_SESSIONVIEW);
					Log.d(TAG, "[Layer 4/6] Bitmap refresh at 300ms");
				}
			}
		}, 300);
		
		// === Layer 5: Bitmap refresh (1000ms) - poor network recovery ===
		uiHandler.postDelayed(new Runnable() {
			@Override
			public void run() {
				if (isFinishing() || isDestroyed() || serverUpdateReceived) return;
				
				if (sessionView != null && bitmap != null) {
					sessionView.addInvalidRegion(new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()));
					uiHandler.sendEmptyMessage(UIHandler.REFRESH_SESSIONVIEW);
					Log.d(TAG, "[Layer 5/6] Bitmap refresh at 1000ms");
				}
			}
		}, 1000);
		
		// === Layer 6: Ultimate fallback (1800ms) - force mouse simulation ===
		uiHandler.postDelayed(new Runnable() {
			@Override
			public void run() {
				if (isFinishing() || isDestroyed()) return;
				
				long timeSinceUpdate = System.currentTimeMillis() - lastServerUpdateTime;
				if (!serverUpdateReceived || timeSinceUpdate > 2000) {
					Log.w(TAG, "[Layer 6/6] No server update, forcing mouse simulation");
					forceTriggerServerUpdate();
				}
			}
		}, 1800);
	}
}

	@Override protected void onPause()
	{
		super.onPause();
		Log.v(TAG, "Session.onPause");

		// hide any visible keyboards
		showKeyboard(false, false);
		
		// Stop graphics updates (save CPU and traffic, keep connection and audio)
		isInForeground = false;
		
		// Only disable graphics if session is fully connected (not during connection)
		if (session != null && sessionRunning && scrollView != null && scrollView.getChildCount() > 0) {
			try {
				// Start foreground service to prevent system from killing the connection
				RdpAudioService.start(this);
				Log.i(TAG, "Foreground service started for background audio");
				
			// Verify if service started successfully
			// Use a short delay to allow service to start
			new android.os.Handler().postDelayed(new Runnable() {
				@Override
				public void run() {
					if (!RdpAudioService.isRunning()) {
						Log.e(TAG, "⚠️ Foreground service failed to start! Will rely on auto-restart mechanism.");
						// WakeLock fallback removed - rely on service auto-restart
					} else {
						Log.i(TAG, "✓ Foreground service verified running");
					}
				}
			}, 500);
				
			// Initialize server update timestamp for timeout detection
			lastServerUpdateTime = System.currentTimeMillis();
			serverUpdateReceived = false;
			Log.d(TAG, "Initialized lastServerUpdateTime for timeout detection");
			
			LibFreeRDP.setClientDecoding(session.getInstance(), false);
			Log.i(TAG, "Background: graphics decoding disabled, connection and audio continue");
				
				// ✅ Release non-critical UI resources (memory optimization)
				releaseNonCriticalUIResources();
				
			// Start application layer heartbeat to keep network connection alive
			startBackgroundKeepalive(session.getInstance());
			Log.i(TAG, "Using Foreground Service + Application Heartbeat for connection stability");
		} catch (Exception e) {
			Log.e(TAG, "Critical error in onPause background optimization", e);
			// WakeLock fallback removed - rely on foreground service and automatic restart
		}
		} else {
			Log.d(TAG, "Skip background optimization: session not fully connected yet");
		}
	}
	
	/**
	 * Acquire WakeLock to keep CPU active in background (fallback if foreground service fails)
	 */
	private void acquireWakeLock() {
		try {
			if (wakeLock == null) {
				android.os.PowerManager pm = (android.os.PowerManager) getSystemService(Context.POWER_SERVICE);
				if (pm != null) {
					wakeLock = pm.newWakeLock(
						android.os.PowerManager.PARTIAL_WAKE_LOCK,
						"FreeRDP::BackgroundConnection"
					);
					wakeLock.setReferenceCounted(false);
				}
			}
			
		if (wakeLock != null && !wakeLock.isHeld()) {
			wakeLock.acquire(5*60*1000L); // 5 minutes max
			Log.i(TAG, "✓ WakeLock acquired (5 min timeout)");
		}
		} catch (Exception e) {
			Log.e(TAG, "Failed to acquire WakeLock", e);
		}
	}
	
	/**
	 * Release WakeLock when no longer needed
	 */
	private void releaseWakeLock() {
		try {
			if (wakeLock != null && wakeLock.isHeld()) {
				wakeLock.release();
				Log.i(TAG, "✓ WakeLock released");
			}
		} catch (Exception e) {
			Log.w(TAG, "Failed to release WakeLock", e);
		}
	}

	private int keepaliveToggle = 0; // Toggle between 0 and 1 for micro movement
	private int keepaliveCount = 0; // Track keepalive count for logging
	private long lastKeepaliveSent = 0; // Track when last keepalive was sent
	
	private void startBackgroundKeepalive(final long inst) {
		// Prevent duplicate keepalive tasks running in parallel
		if (keepaliveTask != null) {
			Log.w(TAG, "Keepalive already running, skip duplicate start");
			return;
		}
		
		keepaliveCount = 0; // Reset counter when starting
		lastKeepaliveSent = System.currentTimeMillis(); // Initialize timestamp
		
		keepaliveTask = new Runnable() {
			@Override
			public void run() {
				if (!sessionRunning || isInForeground || session == null) {
					Log.d(TAG, "Keepalive stopped: sessionRunning=" + sessionRunning + 
					           ", isInForeground=" + isInForeground);
					return;
				}
				
				try {
					// Verify session instance still matches
					if (session.getInstance() != inst) {
						Log.w(TAG, "Keepalive stopped: instance ID mismatch");
						return;
					}
					
					// === 超时检测：检查上次服务器更新是否超过15秒 ===
					long now = System.currentTimeMillis();
					long timeSinceLastUpdate = now - lastServerUpdateTime;
					
					if (lastServerUpdateTime > 0 && timeSinceLastUpdate > KEEPALIVE_TIMEOUT) {
						Log.w(TAG, "⚠️ Connection timeout detected: no server update for " + 
						           (timeSinceLastUpdate/1000) + "s (threshold: " + 
						           (KEEPALIVE_TIMEOUT/1000) + "s)");
						// 触发重连机制
						if (reconnectBookmark != null) {
							Log.i(TAG, "⚠️ Triggering reconnection due to timeout...");
							attemptReconnect();
						}
						return;
					}
					
					// Send lightweight keepalive with 1-pixel micro-movement to ensure server recognizes it
					// Alternates between (1,1) and (2,1) to create minimal detectable movement
					int offset = (keepaliveToggle++ % 2) + 1;
					LibFreeRDP.sendCursorEvent(inst, offset, 1, Mouse.getMoveEvent());
					
					keepaliveCount++;
					lastKeepaliveSent = now;
					
					// === 固定45秒间隔（优化电池消耗）===
					long nextInterval = KEEPALIVE_INTERVAL; // 45 seconds
					
					Log.d(TAG, "Background keepalive sent #" + keepaliveCount + 
					           " (offset=" + offset + ", next=" + (nextInterval/1000) + 
					           "s, last_update=" + (timeSinceLastUpdate/1000) + "s ago)");
					keepaliveHandler.postDelayed(this, nextInterval);
				} catch (Exception e) {
					Log.e(TAG, "Keepalive failed, retry in 3s", e);
					if (keepaliveHandler != null) {
						keepaliveHandler.postDelayed(this, 3000);
					}
				}
			}
		};
		
		// === 首次心跳：45秒后开始（统一间隔）===
		if (keepaliveHandler != null) {
			keepaliveHandler.postDelayed(keepaliveTask, KEEPALIVE_INTERVAL);
			Log.i(TAG, "Background keepalive started (fixed interval: " + 
			           (KEEPALIVE_INTERVAL/1000) + "s, timeout: " + 
			           (KEEPALIVE_TIMEOUT/1000) + "s)");
		}
	}

	private void stopBackgroundKeepalive() {
		if (keepaliveTask != null) {
			keepaliveHandler.removeCallbacks(keepaliveTask);
			keepaliveTask = null;
			Log.i(TAG, "Background keepalive stopped");
		}
	}

	/**
	 * Register network state receiver (only during active sessions)
	 */
	private void registerNetworkReceiver() {
		if (isNetworkReceiverRegistered) {
			Log.d(TAG, "Network receiver already registered, skip");
			return;
		}
		
		try {
			if (networkStateReceiver == null) {
				networkStateReceiver = new com.freerdp.freerdpcore.application.NetworkStateReceiver();
			}
			
			android.content.IntentFilter filter = new android.content.IntentFilter();
			filter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
			registerReceiver(networkStateReceiver, filter);
			
			isNetworkReceiverRegistered = true;
			Log.i(TAG, "✓ Network receiver registered (session active, on-demand)");
		} catch (Exception e) {
			Log.e(TAG, "Failed to register network receiver", e);
		}
	}

	/**
	 * Unregister network state receiver
	 */
	private void unregisterNetworkReceiver() {
		if (!isNetworkReceiverRegistered || networkStateReceiver == null) {
			return;
		}
		
		try {
			unregisterReceiver(networkStateReceiver);
			isNetworkReceiverRegistered = false;
			Log.i(TAG, "✓ Network receiver unregistered (session ended, power saving)");
		} catch (Exception e) {
			Log.w(TAG, "Failed to unregister network receiver", e);
		}
	}

	/**
	 * Force trigger server update by sending simulated mouse movement
	 * This is the ultimate fallback to prevent static screens
	 */
	private void forceTriggerServerUpdate() {
		if (session == null || !sessionRunning || bitmap == null || bitmap.isRecycled()) {
			Log.d(TAG, "Force update skipped: session not ready or bitmap recycled");
			return;
		}
		
		try {
			// Send mouse micro-movement (move 1 pixel and back)
			int centerX = bitmap.getWidth() / 2;
			int centerY = bitmap.getHeight() / 2;
			
			LibFreeRDP.sendCursorEvent(session.getInstance(), centerX, centerY, Mouse.getMoveEvent());
			LibFreeRDP.sendCursorEvent(session.getInstance(), centerX + 1, centerY, Mouse.getMoveEvent());
			LibFreeRDP.sendCursorEvent(session.getInstance(), centerX, centerY, Mouse.getMoveEvent());
			
			Log.w(TAG, "Forced server update by mouse simulation (3 micro-movements)");
			
			// Mark as received to prevent repeated attempts
			serverUpdateReceived = true;
			lastServerUpdateTime = System.currentTimeMillis();
		} catch (Exception e) {
			Log.w(TAG, "Failed to force server update", e);
		}
	}

	private void attemptReconnect() {
		// Check if max attempts reached (thread-safe read)
		if (reconnectAttempts.get() >= MAX_RECONNECT_ATTEMPTS) {
			Log.e(TAG, "Max reconnect attempts reached (" + MAX_RECONNECT_ATTEMPTS + "), giving up");
			showReconnectFailedAndExit();
			return;
		}
		
		if (reconnectBookmark == null) {
			Log.w(TAG, "Reconnect not possible: bookmark is null");
			return;
		}

		// Thread-safe increment and get current attempt
		int currentAttempt = reconnectAttempts.incrementAndGet();
		long delay = RECONNECT_DELAYS[Math.min(currentAttempt - 1, RECONNECT_DELAYS.length - 1)];
		
		Log.i(TAG, "Scheduling reconnect attempt " + currentAttempt + "/" + 
		           MAX_RECONNECT_ATTEMPTS + " in " + (delay/1000) + " seconds");

		// Vibrate once for each reconnect attempt
		try {
			android.os.Vibrator vibrator = (android.os.Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
			if (vibrator != null && vibrator.hasVibrator()) {
				if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
					vibrator.vibrate(android.os.VibrationEffect.createOneShot(200, android.os.VibrationEffect.DEFAULT_AMPLITUDE));
				} else {
					vibrator.vibrate(200);
				}
				Log.d(TAG, "Reconnect vibration triggered (attempt " + currentAttempt + ")");
			}
		} catch (Exception e) {
			Log.w(TAG, "Failed to trigger reconnect vibration", e);
		}

		// Show toast notification
		final String message = "连接断开，" + (delay/1000) + "秒后自动重连 (" + 
		                      currentAttempt + "/" + MAX_RECONNECT_ATTEMPTS + ")";
		runOnUiThread(new Runnable() {
			@Override
			public void run() {
				Toast.makeText(SessionActivity.this, message, Toast.LENGTH_SHORT).show();
			}
		});

		// Schedule reconnection
		keepaliveHandler.postDelayed(new Runnable() {
			@Override
			public void run() {
				Log.i(TAG, "Attempting reconnect (attempt " + reconnectAttempts.get() + ")");
				
				// Clean up current session
				if (session != null) {
					session.setUIEventListener(null);
					LibFreeRDP.disconnect(session.getInstance());
				}
				
				// Start new connection
				connect(reconnectBookmark);
			}
		}, delay);
	}
	
	private void showReconnectFailedAndExit() {
		runOnUiThread(new Runnable() {
			@Override
			public void run() {
				// Play notification sound
				try {
					android.media.RingtoneManager.getRingtone(
						SessionActivity.this,
						android.provider.Settings.System.DEFAULT_NOTIFICATION_URI
					).play();
				} catch (Exception e) {
					Log.w(TAG, "Failed to play notification sound", e);
				}
				
			// Vibrate 3 times to alert user
			try {
				android.os.Vibrator vibrator = (android.os.Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
				if (vibrator != null && vibrator.hasVibrator()) {
					if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
						vibrator.vibrate(android.os.VibrationEffect.createWaveform(
							new long[]{0, 300, 200, 300, 200, 300}, // pattern: vibrate-pause-vibrate-pause-vibrate
							-1 // don't repeat
						));
					} else {
						vibrator.vibrate(new long[]{0, 300, 200, 300, 200, 300}, -1);
					}
					Log.i(TAG, "Failure vibration (3x) triggered");
				}
			} catch (Exception e) {
				Log.w(TAG, "Failed to trigger vibration", e);
			}
			
			// Show alert dialog (must be manually dismissed)
			Log.e(TAG, "showReconnectFailedAndExit called - max reconnect attempts reached");
			AlertDialog dialog = new AlertDialog.Builder(SessionActivity.this)
					.setTitle("连接失败")
					.setMessage("登录失败\n\n已尝试重连 " + MAX_RECONNECT_ATTEMPTS + " 次，仍无法连接到远程服务器。")
					.setCancelable(false)
					.setPositiveButton("确定", new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							// Stop foreground service
							RdpAudioService.stop(SessionActivity.this);
							
							// Clean up and exit
							if (session != null) {
								session.setUIEventListener(null);
								LibFreeRDP.disconnect(session.getInstance());
							}
							
							// Finish activity and return to home screen
							finish();
						}
					})
				.create();
			dialog.show();
			Log.i(TAG, "Reconnect failure dialog shown");
			}
		});
	}

	private void resetReconnectState() {
		reconnectAttempts.set(0); // Thread-safe reset
		manualDisconnect = false; // Reset manual disconnect flag
		Log.d(TAG, "Reconnect state reset");
	}

	@Override protected void onStop()
	{
		super.onStop();
		Log.v(TAG, "Session.onStop");
	}

	@Override protected void onDestroy()
	{
		Log.v(TAG, "Session.onDestroy - START");
		
		// Use try-finally to ensure all cleanup is executed
		try {
			if (connectThread != null)
			{
				try {
					connectThread.interrupt();
				} catch (Exception e) {
					Log.w(TAG, "Failed to interrupt connect thread", e);
				}
			}
			
		// Stop foreground service when activity is destroyed
		try {
			RdpAudioService.stop(this);
			Log.i(TAG, "Foreground service stopped (activity destroyed)");
		} catch (Exception e) {
			Log.w(TAG, "Failed to stop foreground service", e);
		}
		
	// Release WakeLock if held
	try {
		releaseWakeLock();
	} catch (Exception e) {
		Log.w(TAG, "Failed to release WakeLock in onDestroy", e);
	}
	
	// Unregister network receiver
	unregisterNetworkReceiver();
	
	// Clean up all Handler tasks to prevent memory leaks
			try {
				if (keepaliveHandler != null) {
					keepaliveHandler.removeCallbacksAndMessages(null);
					Log.d(TAG, "Keepalive handler cleaned (all tasks removed)");
				}
			} catch (Exception e) {
				Log.w(TAG, "Failed to clean keepalive handler", e);
			}
			
			try {
				if (uiHandler != null) {
					uiHandler.removeCallbacksAndMessages(null);
					Log.d(TAG, "UI handler cleaned (all tasks removed)");
				}
			} catch (Exception e) {
				Log.w(TAG, "Failed to clean UI handler", e);
			}
			
			// Unregister memory pressure receiver
			try {
				if (memoryPressureReceiver != null) {
					unregisterReceiver(memoryPressureReceiver);
					memoryPressureReceiver = null;
					Log.d(TAG, "Memory pressure receiver unregistered");
				}
			} catch (Exception e) {
				Log.w(TAG, "Failed to unregister memory pressure receiver", e);
			}
			
		} finally {
			try {
				super.onDestroy();
				Log.v(TAG, "Session.onDestroy - super.onDestroy() called");
			} catch (Exception e) {
				Log.e(TAG, "Failed in super.onDestroy()", e);
			}
		}
		
		// Activity 完全销毁时清除会话标记（保险）
		if (isFinishing()) {
		getSharedPreferences("rdp_state", MODE_PRIVATE)
			.edit()
			.putBoolean("has_active_session", false)
			.putLong("session_instance", -1)
			.apply();
		Log.d(TAG, "Activity finishing, cleared active session flag and instance");
		}

	// All cleanup operations with exception handling
	try {
			Collection<SessionState> sessions = GlobalApp.getSessions();
			for (SessionState s : sessions) {
				try {
					LibFreeRDP.disconnect(s.getInstance());
				} catch (Exception e) {
					Log.w(TAG, "Failed to disconnect session " + s.getInstance(), e);
				}
			}
		} catch (Exception e) {
			Log.w(TAG, "Failed to disconnect sessions", e);
		}

		try {
			unregisterReceiver(libFreeRDPBroadcastReceiver);
		} catch (Exception e) {
			Log.w(TAG, "Failed to unregister broadcast receiver (may already be unregistered)", e);
		}

		try {
			if (mClipboardManager != null) {
				mClipboardManager.removeClipboardboardChangedListener(this);
			}
		} catch (Exception e) {
			Log.w(TAG, "Failed to remove clipboard listener", e);
		}

		try {
			if (session != null) {
				GlobalApp.freeSession(session.getInstance());
				session = null;
			}
		} catch (Exception e) {
			Log.e(TAG, "Failed to free session", e);
		}
		
		Log.v(TAG, "Session.onDestroy - END");
	}

	@Override public void onConfigurationChanged(Configuration newConfig)
	{
		super.onConfigurationChanged(newConfig);

		// reload keyboard resources (changed from landscape)
		modifiersKeyboard = new Keyboard(getApplicationContext(), R.xml.modifiers_keyboard);
		specialkeysKeyboard = new Keyboard(getApplicationContext(), R.xml.specialkeys_keyboard);
		numpadKeyboard = new Keyboard(getApplicationContext(), R.xml.numpad_keyboard);
		cursorKeyboard = new Keyboard(getApplicationContext(), R.xml.cursor_keyboard);

	// apply loaded keyboards
	keyboardView.setKeyboard(specialkeysKeyboard);
	modifiersKeyboardView.setKeyboard(modifiersKeyboard);

	// 设置布局延伸到状态栏和导航栏下方，但保持它们始终可见
	mDecor.setSystemUiVisibility(
	    View.SYSTEM_UI_FLAG_LAYOUT_STABLE |
	    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |
	    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
	);
	
	// 设置半透明导航栏和状态栏（黑色半透明），始终显示
	if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
		getWindow().setNavigationBarColor(0x40000000); // 25%透明度的黑色
		getWindow().setStatusBarColor(0x40000000); // 25%透明度的黑色
	}
}

	private void processIntent(Intent intent)
	{
		// get either session instance or create one from a bookmark/uri
		Bundle bundle = intent.getExtras();
		Uri openUri = intent.getData();
		if (openUri != null)
		{
			// Launched from URI, e.g:
			// freerdp://user@ip:port/connect?sound=&rfx=&p=password&clipboard=%2b&themes=-
			connect(openUri);
		}
		else if (bundle.containsKey(PARAM_INSTANCE))
		{
			int inst = bundle.getInt(PARAM_INSTANCE);
			session = GlobalApp.getSession(inst);
			bitmap = session.getSurface().getBitmap();
			bindSession();
		}
		else if (bundle.containsKey(PARAM_CONNECTION_REFERENCE))
		{
			BookmarkBase bookmark = null;
			String refStr = bundle.getString(PARAM_CONNECTION_REFERENCE);
			if (ConnectionReference.isHostnameReference(refStr))
			{
				bookmark = new ManualBookmark();
				bookmark.<ManualBookmark>get().setHostname(ConnectionReference.getHostname(refStr));
			}
			else if (ConnectionReference.isBookmarkReference(refStr))
			{
				if (ConnectionReference.isManualBookmarkReference(refStr))
					bookmark = GlobalApp.getManualBookmarkGateway().findById(
					    ConnectionReference.getManualBookmarkId(refStr));
				else
					assert false;
			}

			if (bookmark != null)
			{
			// 设置屏幕方向
			int orientation = bookmark.getAdvancedSettings().getScreenOrientation();
			Log.i(TAG, "Bookmark screen orientation value: " + orientation);
			switch (orientation)
			{
				case 0: // 自动
					setRequestedOrientation(android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
					Log.i(TAG, "Screen orientation set to: UNSPECIFIED (Auto)");
					break;
				case 1: // 锁定横屏（顺时针旋转90度）= 左横屏（Home键在左）
					setRequestedOrientation(android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
					Log.i(TAG, "Screen orientation set to: LANDSCAPE (Clockwise 90°, Home on left)");
					break;
				case 2: // 锁定横屏（逆时针旋转90度）= 右横屏（Home键在右）
					setRequestedOrientation(android.content.pm.ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
					Log.i(TAG, "Screen orientation set to: REVERSE_LANDSCAPE (Counter-clockwise 90°, Home on right)");
					break;
				case 3: // 锁定竖屏（支持正反两个竖屏方向）
					setRequestedOrientation(android.content.pm.ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
					Log.i(TAG, "Screen orientation set to: SENSOR_PORTRAIT");
					break;
				default:
					Log.w(TAG, "Unknown screen orientation value: " + orientation);
					setRequestedOrientation(android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
					break;
			}
				
				connect(bookmark);
			}
			else
				closeSessionActivity(RESULT_CANCELED);
		}
		else
		{
			// no session found - exit
			closeSessionActivity(RESULT_CANCELED);
		}
	}

	private void connect(BookmarkBase bookmark)
	{
		// 如果是从数据库加载的 bookmark（有ID），重新加载以确保获取最新设置
		if (bookmark != null && bookmark.getId() > 0) {
			try {
				BookmarkBase latestBookmark = GlobalApp.getManualBookmarkGateway().findById(bookmark.getId());
				if (latestBookmark != null) {
					bookmark = latestBookmark;
					Log.i(TAG, "connect: Reloaded bookmark from DB (ID=" + bookmark.getId() + ") to get latest settings");
				}
			} catch (Exception e) {
				Log.w(TAG, "connect: Failed to reload bookmark from DB: " + e.getMessage());
			}
		}
		
		// Save bookmark for auto-reconnection
		reconnectBookmark = bookmark;
		
		session = GlobalApp.createSession(bookmark, getApplicationContext());

		BookmarkBase.ScreenSettings screenSettings =
		    session.getBookmark().getActiveScreenSettings();
		Log.v(TAG, "Screen Resolution: " + screenSettings.getResolutionString());
		if (screenSettings.isAutomatic())
		{
			if ((getResources().getConfiguration().screenLayout &
			     Configuration.SCREENLAYOUT_SIZE_MASK) >= Configuration.SCREENLAYOUT_SIZE_LARGE)
			{
				// large screen device i.e. tablet: simply use screen info
				screenSettings.setHeight(screen_height);
				screenSettings.setWidth(screen_width);
			}
			else
			{
				// small screen device i.e. phone:
				// Automatic uses the largest side length of the screen and
				// makes a 16:10 resolution setting out of it
				int screenMax = Math.max(screen_width, screen_height);
				screenSettings.setHeight(screenMax);
				screenSettings.setWidth((int)((float)screenMax * 1.6f));
			}
		}
		if (screenSettings.isFitScreen())
		{
			screenSettings.setHeight(screen_height);
			screenSettings.setWidth(screen_width);
		}

		connectWithTitle(bookmark.getLabel());
	}

	private void connect(Uri openUri)
	{
		session = GlobalApp.createSession(openUri, getApplicationContext());

		connectWithTitle(openUri.getAuthority());
	}

	static class ConnectThread extends Thread
	{
		private final SessionState runnableSession;
		private final Context context;

		public ConnectThread(@NonNull Context context, @NonNull SessionState session)
		{
			this.context = context;
			runnableSession = session;
		}

		public void run()
		{
			runnableSession.connect(context.getApplicationContext());
		}
	}

	private ConnectThread connectThread = null;

	private void connectWithTitle(String title)
	{
		session.setUIEventListener(this);

		progressDialog = new ProgressDialog(this);
		progressDialog.setTitle(title);
		progressDialog.setMessage(getResources().getText(R.string.dlg_msg_connecting));
		progressDialog.setButton(
		    ProgressDialog.BUTTON_NEGATIVE, "Cancel", new DialogInterface.OnClickListener() {
			    @Override public void onClick(DialogInterface dialog, int which)
			    {
				    connectCancelledByUser = true;
				    LibFreeRDP.cancelConnection(session.getInstance());
			    }
		    });
		progressDialog.setCancelable(false);
		progressDialog.show();

		connectThread = new ConnectThread(getApplicationContext(), session);
		connectThread.start();
	}

	// binds the current session to the activity by wiring it up with the
	// sessionView and updating all internal objects accordingly
	private void bindSession()
	{
	Log.v(TAG, "bindSession called");
	session.setUIEventListener(this);
	sessionView.onSurfaceChange(session);
	scrollView.requestLayout();
	keyboardMapper.reset(this);
	// 设置布局延伸到状态栏和导航栏下方，但保持它们始终可见
	mDecor.setSystemUiVisibility(
	    View.SYSTEM_UI_FLAG_LAYOUT_STABLE |
	    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |
	    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
	);
	
	// 设置半透明导航栏和状态栏（黑色半透明），始终显示
	if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
		getWindow().setNavigationBarColor(0x40000000); // 25%透明度的黑色
		getWindow().setStatusBarColor(0x40000000); // 25%透明度的黑色
	}
}

	private void setSoftInputState(boolean state)
	{
		InputMethodManager mgr = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);

		if (state)
		{
			mgr.showSoftInput(sessionView, InputMethodManager.SHOW_FORCED);
		}
		else
		{
			mgr.hideSoftInputFromWindow(sessionView.getWindowToken(), 0);
		}
	}

	// displays either the system or the extended keyboard or non of them
	private void showKeyboard(final boolean showSystemKeyboard, final boolean showExtendedKeyboard)
	{
		// no matter what we are doing ... hide the zoom controls
		// onScrollChange notification showing the control again ...
		// i think check for "preference_key_ui_hide_zoom_controls" preference should be there
		uiHandler.removeMessages(UIHandler.SHOW_ZOOMCONTROLS);
		uiHandler.sendEmptyMessage(UIHandler.HIDE_ZOOMCONTROLS);

		InputMethodManager mgr = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);

		if (showSystemKeyboard)
		{
			// hide extended keyboard
			keyboardView.setVisibility(View.GONE);
			// show system keyboard
			setSoftInputState(true);

			// show modifiers keyboard
			modifiersKeyboardView.setVisibility(View.VISIBLE);
		}
		else if (showExtendedKeyboard)
		{
			// hide system keyboard
			setSoftInputState(false);

			// show extended keyboard
			keyboardView.setKeyboard(specialkeysKeyboard);
			keyboardView.setVisibility(View.VISIBLE);
			modifiersKeyboardView.setVisibility(View.VISIBLE);
		}
		else
		{
			// hide both
			setSoftInputState(false);
			keyboardView.setVisibility(View.GONE);
			modifiersKeyboardView.setVisibility(View.GONE);

			// clear any active key modifiers)
			keyboardMapper.clearlAllModifiers();
		}

		sysKeyboardVisible = showSystemKeyboard;
		extKeyboardVisible = showExtendedKeyboard;
	}

	private void closeSessionActivity(int resultCode)
	{
		// 清除活跃会话标记（停止服务自动重启）
	getSharedPreferences("rdp_state", MODE_PRIVATE)
		.edit()
		.putBoolean("has_active_session", false)
		.putLong("session_instance", -1)
		.apply();
	
	// 注销网络监听器
	unregisterNetworkReceiver();
	
	// 停止前台服务
	RdpAudioService.stop(this);
		
		// Go back to home activity (and send intent data back to home)
		setResult(resultCode, getIntent());
		finish();
	}

	// update the state of our modifier keys
	private void updateModifierKeyStates()
	{
		// check if any key is in the keycodes list

		List<Keyboard.Key> keys = modifiersKeyboard.getKeys();
		for (Keyboard.Key curKey : keys)
		{
			// if the key is a sticky key - just set it to off
			if (curKey.sticky)
			{
				switch (keyboardMapper.getModifierState(curKey.codes[0]))
				{
					case KeyboardMapper.KEYSTATE_ON:
						curKey.on = true;
						curKey.pressed = false;
						break;

					case KeyboardMapper.KEYSTATE_OFF:
						curKey.on = false;
						curKey.pressed = false;
						break;

					case KeyboardMapper.KEYSTATE_LOCKED:
						curKey.on = true;
						curKey.pressed = true;
						break;
				}
			}
		}

		// refresh image
		modifiersKeyboardView.invalidateAllKeys();
	}

	private void sendDelayedMoveEvent(int x, int y)
	{
		if (session == null || uiHandler == null) {
			return;
		}
		
		try {
			if (uiHandler.hasMessages(UIHandler.SEND_MOVE_EVENT))
			{
				uiHandler.removeMessages(UIHandler.SEND_MOVE_EVENT);
				discardedMoveEvents++;
			}
			else
				discardedMoveEvents = 0;

			if (discardedMoveEvents > MAX_DISCARDED_MOVE_EVENTS)
				LibFreeRDP.sendCursorEvent(session.getInstance(), x, y, Mouse.getMoveEvent());
			else
				uiHandler.sendMessageDelayed(Message.obtain(null, UIHandler.SEND_MOVE_EVENT, x, y),
				                             SEND_MOVE_EVENT_TIMEOUT);
		} catch (Exception e) {
			Log.e(TAG, "Exception in sendDelayedMoveEvent", e);
		}
	}

	private void cancelDelayedMoveEvent()
	{
		if (uiHandler != null) {
			try {
				uiHandler.removeMessages(UIHandler.SEND_MOVE_EVENT);
			} catch (Exception e) {
				Log.e(TAG, "Exception in cancelDelayedMoveEvent", e);
			}
		}
	}

	@Override public boolean onCreateOptionsMenu(Menu menu)
	{
		getMenuInflater().inflate(R.menu.session_menu, menu);
		
		// Store reference to ALT key menu item
		altKeyMenuItem = menu.findItem(R.id.session_alt_key);
		// Initialize ALT key to inactive state (gray)
		updateAltKeyIcon(false);
		
		return true;
	}

	@Override public boolean onOptionsItemSelected(MenuItem item)
	{
		// refer to http://tools.android.com/tips/non-constant-fields why we
		// can't use switch/case here ..
		int itemId = item.getItemId();

		if (itemId == R.id.session_zoom_310)
		{
			// Zoom to 310% (3.1x)
			if (sessionView != null) {
				sessionView.setZoom(3.1f);
				Log.d(TAG, "Zoom set to 310% (3.1x)");
				Toast.makeText(this, "缩放: 310%", Toast.LENGTH_SHORT).show();
			}
		}
		else if (itemId == R.id.session_zoom_400)
		{
			// Zoom to 400% (4.0x)
			if (sessionView != null) {
				sessionView.setZoom(4.0f);
				Log.d(TAG, "Zoom set to 400% (4.0x)");
				Toast.makeText(this, "缩放: 400%", Toast.LENGTH_SHORT).show();
			}
		}
	else if (itemId == R.id.session_touch_pointer)
	{
		// toggle touch pointer
		if (touchPointerView.getVisibility() == View.VISIBLE)
		{
			touchPointerView.setVisibility(View.INVISIBLE);
			sessionView.setTouchPointerPadding(0, 0);
		}
		else
		{
			touchPointerView.setVisibility(View.VISIBLE);
			
			// 每次显示时，将触摸指针移动到屏幕中间
			touchPointerView.setPosition(
			    (screen_width - touchPointerView.getPointerWidth()) / 2,
			    (screen_height - touchPointerView.getPointerHeight()) / 2
			);
			
			sessionView.setTouchPointerPadding(touchPointerView.getPointerWidth(),
			                                   touchPointerView.getPointerHeight());
		}
	}
		else if (itemId == R.id.session_sys_keyboard)
		{
			showKeyboard(!sysKeyboardVisible, false);
		}
		else if (itemId == R.id.session_ext_keyboard)
		{
			showKeyboard(false, !extKeyboardVisible);
		}
		else if (itemId == R.id.session_alt_key)
		{
			// Toggle ALT key state
			isAltKeyActive = !isAltKeyActive;
			updateAltKeyIcon(isAltKeyActive);
			
			// Send ALT key press/release to RDP session using VK_LMENU (0xA4)
			// This is the Windows virtual key code for left ALT key
			final int VK_LMENU = 0xA4;
			if (isAltKeyActive) {
				// Press ALT key (key down) - icon turns RED
				processVirtualKey(VK_LMENU, true);
				Log.d(TAG, "ALT key activated (VK_LMENU pressed, icon RED)");
			} else {
				// Release ALT key (key up) - icon turns GRAY
				processVirtualKey(VK_LMENU, false);
				Log.d(TAG, "ALT key deactivated (VK_LMENU released, icon GRAY)");
			}
		}
		else if (itemId == R.id.session_disconnect)
		{
			showKeyboard(false, false);
			manualDisconnect = true; // Mark as manual disconnect (no auto-reconnect)
			Log.i(TAG, "Manual disconnect requested by user");
			LibFreeRDP.disconnect(session.getInstance());
		}

		return true;
	}

	/**
	 * Update ALT key appearance based on active state
	 * @param isActive true = red text (active), false = gray text (inactive)
	 */
	private void updateAltKeyIcon(boolean isActive) {
		if (altKeyMenuItem != null) {
			// Use SpannableString to set text color and style
			SpannableString spanString = new SpannableString("ALT");
			// Set color: RED when active, GRAY when inactive
			spanString.setSpan(new ForegroundColorSpan(
				isActive ? Color.RED : Color.GRAY), 
				0, spanString.length(), 0);
			// Set bold style
			spanString.setSpan(new StyleSpan(Typeface.BOLD), 
				0, spanString.length(), 0);
			altKeyMenuItem.setTitle(spanString);
		}
	}

	@Override public void onBackPressed()
	{
		// 只允许返回键用于隐藏键盘，其他情况不做任何操作
		// 这样可以防止返回键退出远程桌面或发送Alt+F4到远程系统
		if (sysKeyboardVisible || extKeyboardVisible)
		{
			// 键盘可见时，返回键用于隐藏键盘（保持手机正常行为）
			showKeyboard(false, false);
		}
		// 其他情况：不调用super.onBackPressed()，不发送Alt+F4
		// 完全忽略返回键，防止影响远程桌面
		// 如需断开连接，请使用菜单 -> 断开连接
	}

	@Override public boolean onKeyLongPress(int keyCode, KeyEvent event)
	{
		// Long press back key: removed manual disconnect feature
		// Use menu -> disconnect to manually close connection
		return super.onKeyLongPress(keyCode, event);
	}

	// android keyboard input handling
	// We always use the unicode value to process input from the android
	// keyboard except if key modifiers
	// (like Win, Alt, Ctrl) are activated. In this case we will send the
	// virtual key code to allow key
	// combinations (like Win + E to open the explorer).
	@Override public boolean onKeyDown(int keycode, KeyEvent event)
	{
		return keyboardMapper.processAndroidKeyEvent(event);
	}

	@Override public boolean onKeyUp(int keycode, KeyEvent event)
	{
		return keyboardMapper.processAndroidKeyEvent(event);
	}

	// onKeyMultiple is called for input of some special characters like umlauts
	// and some symbol characters
	@Override public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)
	{
		return keyboardMapper.processAndroidKeyEvent(event);
	}

	// ****************************************************************************
	// KeyboardView.KeyboardActionEventListener
	@Override public void onKey(int primaryCode, int[] keyCodes)
	{
		keyboardMapper.processCustomKeyEvent(primaryCode);
	}

	@Override public void onText(CharSequence text)
	{
	}

	@Override public void swipeRight()
	{
	}

	@Override public void swipeLeft()
	{
	}

	@Override public void swipeDown()
	{
	}

	@Override public void swipeUp()
	{
	}

	@Override public void onPress(int primaryCode)
	{
	}

	@Override public void onRelease(int primaryCode)
	{
	}

	// ****************************************************************************
	// KeyboardMapper.KeyProcessingListener implementation
	@Override public void processVirtualKey(int virtualKeyCode, boolean down)
	{
		LibFreeRDP.sendKeyEvent(session.getInstance(), virtualKeyCode, down);
	}

	@Override public void processUnicodeKey(int unicodeKey)
	{
		LibFreeRDP.sendUnicodeKeyEvent(session.getInstance(), unicodeKey, true);
		LibFreeRDP.sendUnicodeKeyEvent(session.getInstance(), unicodeKey, false);
	}

	@Override public void switchKeyboard(int keyboardType)
	{
		switch (keyboardType)
		{
			case KeyboardMapper.KEYBOARD_TYPE_FUNCTIONKEYS:
				keyboardView.setKeyboard(specialkeysKeyboard);
				break;

			case KeyboardMapper.KEYBOARD_TYPE_NUMPAD:
				keyboardView.setKeyboard(numpadKeyboard);
				break;

			case KeyboardMapper.KEYBOARD_TYPE_CURSOR:
				keyboardView.setKeyboard(cursorKeyboard);
				break;

			default:
				break;
		}
	}

	@Override public void modifiersChanged()
	{
		updateModifierKeyStates();
	}

	// ****************************************************************************
	// LibFreeRDP UI event listener implementation
	@Override public void OnSettingsChanged(int width, int height, int bpp)
	{

		if (bpp > 16)
			bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
		else
			bitmap = Bitmap.createBitmap(width, height, Config.RGB_565);

		session.setSurface(new BitmapDrawable(getResources(), bitmap));

		if (session.getBookmark() == null)
		{
			// Return immediately if we launch from URI
			return;
		}

		// check this settings and initial settings - if they are not equal the
		// server doesn't support our settings
		// FIXME: the additional check (settings.getWidth() != width + 1) is for
		// the RDVH bug fix to avoid accidental notifications
		// (refer to android_freerdp.c for more info on this problem)
		BookmarkBase.ScreenSettings settings = session.getBookmark().getActiveScreenSettings();
		if ((settings.getWidth() != width && settings.getWidth() != width + 1) ||
		    settings.getHeight() != height || settings.getColors() != bpp)
			uiHandler.sendMessage(
			    Message.obtain(null, UIHandler.DISPLAY_TOAST,
			                   getResources().getText(R.string.info_capabilities_changed)));
	}

	// Track foreground state for background optimization
	private boolean isInForeground = true;
	
	// Server update tracking (prevent static screen after unlock)
	private volatile boolean serverUpdateReceived = false;
	private volatile long lastServerUpdateTime = 0;
	
	// Background keepalive (application layer heartbeat)
	private Handler keepaliveHandler = new Handler();
	private Runnable keepaliveTask;
	private static final long KEEPALIVE_INTERVAL = 45000; // 45 seconds (optimized for battery saving)
	private static final long KEEPALIVE_TIMEOUT = 15000; // 15 seconds timeout detection
	
	// Auto reconnection (smart reconnection with exponential backoff)
	// Thread-safe counter to prevent race conditions in multi-threaded reconnection logic
	private AtomicInteger reconnectAttempts = new AtomicInteger(0);
	private static final int MAX_RECONNECT_ATTEMPTS = 10;
	private static final long[] RECONNECT_DELAYS = {
		5000,    // 1st: 5 seconds
		10000,   // 2nd: 10 seconds
		15000,   // 3rd: 15 seconds
		15000,   // 4th: 15 seconds
		15000,   // 5th: 15 seconds
		15000,   // 6th: 15 seconds
		15000,   // 7th: 15 seconds
		15000,   // 8th: 15 seconds
		15000,   // 9th: 15 seconds
		15000    // 10th: 15 seconds
	};
	private BookmarkBase reconnectBookmark = null;

	@Override public void OnGraphicsUpdate(int x, int y, int width, int height)
	{
		// Mark that we received a server update
		serverUpdateReceived = true;
		lastServerUpdateTime = System.currentTimeMillis();
		
		// Skip graphics update in background (save CPU, keep audio)
		if (!isInForeground) {
			return;
		}

		LibFreeRDP.updateGraphics(session.getInstance(), bitmap, x, y, width, height);

		sessionView.addInvalidRegion(new Rect(x, y, x + width, y + height));

		/*
		 * since sessionView can only be modified from the UI thread any
		 * modifications to it need to be scheduled
		 */

		uiHandler.sendEmptyMessage(UIHandler.REFRESH_SESSIONVIEW);
	}

	@Override public void OnGraphicsResize(int width, int height, int bpp)
	{
		// replace bitmap
		if (bpp > 16)
			bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
		else
			bitmap = Bitmap.createBitmap(width, height, Config.RGB_565);
		session.setSurface(new BitmapDrawable(getResources(), bitmap));

		// Set default zoom to 310% (3.1x) when graphics is first initialized
		// Use flag to ensure it's only done once, and use UI thread to avoid crashes
		if (!hasSetDefaultZoom && sessionView != null && bitmap != null) {
			sessionView.post(new Runnable() {
				@Override
				public void run() {
					// Enhanced checks: Activity lifecycle + session state + bitmap
					if (sessionView != null && session != null && sessionRunning 
					    && bitmap != null && !isFinishing() && !isDestroyed()) {
						try {
							sessionView.setZoom(3.1f);
							scrollView.requestLayout();
							hasSetDefaultZoom = true;
							Log.d(TAG, "Default zoom set to 310% (3.1x) on graphics resize");
						} catch (Exception e) {
							Log.e(TAG, "Failed to set default zoom", e);
						}
					} else {
						Log.d(TAG, "Default zoom skipped (session not ready or Activity destroyed)");
					}
				}
			});
		}

		/*
		 * since sessionView can only be modified from the UI thread any
		 * modifications to it need to be scheduled
		 */
		uiHandler.sendEmptyMessage(UIHandler.GRAPHICS_CHANGED);
	}

	@Override
	public boolean OnAuthenticate(StringBuilder username, StringBuilder domain,
	                              StringBuilder password)
	{
		// this is where the return code of our dialog will be stored
		callbackDialogResult = false;

		// set text fields
		((EditText)userCredView.findViewById(R.id.editTextUsername)).setText(username);
		((EditText)userCredView.findViewById(R.id.editTextDomain)).setText(domain);
		((EditText)userCredView.findViewById(R.id.editTextPassword)).setText(password);

		// start dialog in UI thread
		uiHandler.sendMessage(Message.obtain(null, UIHandler.SHOW_DIALOG, dlgUserCredentials));

		// wait for result
		try
		{
			synchronized (dlgUserCredentials)
			{
				dlgUserCredentials.wait();
			}
		}
		catch (InterruptedException e)
		{
		}

		// clear buffers
		username.setLength(0);
		domain.setLength(0);
		password.setLength(0);

		// read back user credentials
		username.append(
		    ((EditText)userCredView.findViewById(R.id.editTextUsername)).getText().toString());
		domain.append(
		    ((EditText)userCredView.findViewById(R.id.editTextDomain)).getText().toString());
		password.append(
		    ((EditText)userCredView.findViewById(R.id.editTextPassword)).getText().toString());

		return callbackDialogResult;
	}

	@Override
	public boolean OnGatewayAuthenticate(StringBuilder username, StringBuilder domain,
	                                     StringBuilder password)
	{
		// this is where the return code of our dialog will be stored
		callbackDialogResult = false;

		// set text fields
		((EditText)userCredView.findViewById(R.id.editTextUsername)).setText(username);
		((EditText)userCredView.findViewById(R.id.editTextDomain)).setText(domain);
		((EditText)userCredView.findViewById(R.id.editTextPassword)).setText(password);

		// start dialog in UI thread
		uiHandler.sendMessage(Message.obtain(null, UIHandler.SHOW_DIALOG, dlgUserCredentials));

		// wait for result
		try
		{
			synchronized (dlgUserCredentials)
			{
				dlgUserCredentials.wait();
			}
		}
		catch (InterruptedException e)
		{
		}

		// clear buffers
		username.setLength(0);
		domain.setLength(0);
		password.setLength(0);

		// read back user credentials
		username.append(
		    ((EditText)userCredView.findViewById(R.id.editTextUsername)).getText().toString());
		domain.append(
		    ((EditText)userCredView.findViewById(R.id.editTextDomain)).getText().toString());
		password.append(
		    ((EditText)userCredView.findViewById(R.id.editTextPassword)).getText().toString());

		return callbackDialogResult;
	}

	@Override
	public int OnVerifiyCertificateEx(String host, long port, String commonName, String subject,
	                                  String issuer, String fingerprint, long flags)
	{
		// see if global settings says accept all
		if (ApplicationSettingsActivity.getAcceptAllCertificates(this))
			return 0;

		// this is where the return code of our dialog will be stored
		callbackDialogResult = false;

		// set message
		String msg = getResources().getString(R.string.dlg_msg_verify_certificate);
		String type = "RDP-Server";
		if ((flags & LibFreeRDP.VERIFY_CERT_FLAG_GATEWAY) != 0)
			type = "RDP-Gateway";
		if ((flags & LibFreeRDP.VERIFY_CERT_FLAG_REDIRECT) != 0)
			type = "RDP-Redirect";
		msg += "\n\n" + type + ": " + host + ":" + port;

		msg += "\n\nSubject: " + subject + "\nIssuer: " + issuer;

		if ((flags & LibFreeRDP.VERIFY_CERT_FLAG_FP_IS_PEM) != 0)
			msg += "\nCertificate: " + fingerprint;
		else
			msg += "\nFingerprint: " + fingerprint;
		dlgVerifyCertificate.setMessage(msg);

		// start dialog in UI thread
		uiHandler.sendMessage(Message.obtain(null, UIHandler.SHOW_DIALOG, dlgVerifyCertificate));

		// wait for result
		try
		{
			synchronized (dlgVerifyCertificate)
			{
				dlgVerifyCertificate.wait();
			}
		}
		catch (InterruptedException e)
		{
		}

		return callbackDialogResult ? 1 : 0;
	}

	@Override
	public int OnVerifyChangedCertificateEx(String host, long port, String commonName,
	                                        String subject, String issuer, String fingerprint,
	                                        String oldSubject, String oldIssuer,
	                                        String oldFingerprint, long flags)
	{
		// see if global settings says accept all
		if (ApplicationSettingsActivity.getAcceptAllCertificates(this))
			return 0;

		// this is where the return code of our dialog will be stored
		callbackDialogResult = false;

		// set message
		String msg = getResources().getString(R.string.dlg_msg_verify_certificate);
		String type = "RDP-Server";
		if ((flags & LibFreeRDP.VERIFY_CERT_FLAG_GATEWAY) != 0)
			type = "RDP-Gateway";
		if ((flags & LibFreeRDP.VERIFY_CERT_FLAG_REDIRECT) != 0)
			type = "RDP-Redirect";
		msg += "\n\n" + type + ": " + host + ":" + port;
		msg += "\n\nSubject: " + subject + "\nIssuer: " + issuer;
		if ((flags & LibFreeRDP.VERIFY_CERT_FLAG_FP_IS_PEM) != 0)
			msg += "\nCertificate: " + fingerprint;
		else
			msg += "\nFingerprint: " + fingerprint;
		dlgVerifyCertificate.setMessage(msg);

		// start dialog in UI thread
		uiHandler.sendMessage(Message.obtain(null, UIHandler.SHOW_DIALOG, dlgVerifyCertificate));

		// wait for result
		try
		{
			synchronized (dlgVerifyCertificate)
			{
				dlgVerifyCertificate.wait();
			}
		}
		catch (InterruptedException e)
		{
		}

		return callbackDialogResult ? 1 : 0;
	}

	@Override public void OnRemoteClipboardChanged(String data)
	{
		Log.v(TAG, "OnRemoteClipboardChanged: " + data);
		mClipboardManager.setClipboardData(data);
	}

	@Override public void OnRemoteCursorUpdate(byte[] bitmapData, int width, int height, int hotX, int hotY)
	{
		Log.i(TAG, "SessionActivity.OnRemoteCursorUpdate: " + width + "x" + height + " hotspot(" + hotX + "," + hotY + ")");
		Log.i(TAG, "bitmapData: " + (bitmapData != null ? bitmapData.length + " bytes" : "null"));
		Log.i(TAG, "sessionView: " + (sessionView != null ? "not null" : "null"));
		
		if (sessionView != null)
		{
			sessionView.updateRemoteCursor(bitmapData, width, height, hotX, hotY);
			Log.i(TAG, "updateRemoteCursor called");
		}
	}

	@Override public void OnCursorTypeChanged(int cursorType)
	{
		Log.i(TAG, "SessionActivity.OnCursorTypeChanged: cursorType=" + cursorType);
		
		if (touchPointerView != null)
		{
			touchPointerView.setCursorType(cursorType);
			Log.i(TAG, "TouchPointerView.setCursorType called with type=" + cursorType);
		}
	}

	// ****************************************************************************
	// ScrollView2DListener implementation
	private void resetZoomControlsAutoHideTimeout()
	{
		uiHandler.removeMessages(UIHandler.HIDE_ZOOMCONTROLS);
		uiHandler.sendEmptyMessageDelayed(UIHandler.HIDE_ZOOMCONTROLS,
		                                  ZOOMCONTROLS_AUTOHIDE_TIMEOUT);
	}

	@Override public void onScrollChanged(ScrollView2D scrollView, int x, int y, int oldx, int oldy)
	{
		try {
			if (sessionView == null || zoomControls == null) {
				return;
			}
			
			zoomControls.setIsZoomInEnabled(!sessionView.isAtMaxZoom());
			zoomControls.setIsZoomOutEnabled(!sessionView.isAtMinZoom());

			if (sysKeyboardVisible || extKeyboardVisible)
				return;

			if (!ApplicationSettingsActivity.getHideZoomControls(this))
			{
				if (uiHandler != null) {
					uiHandler.sendEmptyMessage(UIHandler.SHOW_ZOOMCONTROLS);
					resetZoomControlsAutoHideTimeout();
				}
			}
			
			// 屏幕滚动时，发送鼠标移动事件到远程
			// 这样Windows能实时更新光标样式（双箭头、手型等）
			if (session != null && touchPointerView != null && 
			    touchPointerView.getVisibility() == View.VISIBLE)
			{
				Point p = touchPointerView.getRemoteCoordinate();
				
				// 空指针检查
				if (p == null) {
					return;
				}
				
				// 边界检查
				if (bitmap != null && !bitmap.isRecycled())
				{
					p.x = Math.max(0, Math.min(p.x, bitmap.getWidth()));
					p.y = Math.max(0, Math.min(p.y, bitmap.getHeight()));
				}
				
				LibFreeRDP.sendCursorEvent(session.getInstance(), p.x, p.y, Mouse.getMoveEvent());
				Log.v(TAG, "Scroll changed, sent mouse move to: (" + p.x + "," + p.y + ")");
			}
		} catch (Exception e) {
			Log.e(TAG, "Exception in onScrollChanged", e);
		}
	}

	// ****************************************************************************
	// SessionView.SessionViewListener
	@Override public void onSessionViewBeginTouch()
	{
		scrollView.setScrollEnabled(false);
	}

	@Override public void onSessionViewEndTouch()
	{
		scrollView.setScrollEnabled(true);
	}

	@Override public void onSessionViewLeftTouch(int x, int y, boolean down)
	{
		if (session == null) {
			return;
		}
		
		try {
			if (!down)
				cancelDelayedMoveEvent();

			LibFreeRDP.sendCursorEvent(session.getInstance(), x, y,
			                           toggleMouseButtons ? Mouse.getRightButtonEvent(this, down)
			                                              : Mouse.getLeftButtonEvent(this, down));

			if (!down)
				toggleMouseButtons = false;
		} catch (Exception e) {
			Log.e(TAG, "Failed to send left touch event", e);
		}
	}

	public void onSessionViewRightTouch(int x, int y, boolean down)
	{
		if (!down)
			toggleMouseButtons = !toggleMouseButtons;
	}

	@Override public void onSessionViewMove(int x, int y)
	{
		if (session != null) {
			sendDelayedMoveEvent(x, y);
		}
	}

	@Override public void onSessionViewScroll(boolean down)
	{
		if (session == null) {
			return;
		}
		
		try {
			LibFreeRDP.sendCursorEvent(session.getInstance(), 0, 0, Mouse.getScrollEvent(this, down));
		} catch (Exception e) {
			Log.e(TAG, "Failed to send scroll event", e);
		}
	}

	// ****************************************************************************
	// TouchPointerView.TouchPointerListener
	@Override public void onTouchPointerClose()
	{
		try {
			if (touchPointerView != null) {
				touchPointerView.setVisibility(View.INVISIBLE);
			}
			if (sessionView != null) {
				sessionView.setTouchPointerPadding(0, 0);
			}
		} catch (Exception e) {
			Log.e(TAG, "Failed to close touch pointer", e);
		}
	}

	@Override public void onTouchPointerLeftClick(Point remoteCoord, boolean down)
	{
		// 空指针检查
		if (remoteCoord == null || session == null) {
			Log.w(TAG, "onTouchPointerLeftClick: null parameter");
			return;
		}
		
		// 边界检查
		if (bitmap != null && !bitmap.isRecycled())
		{
			remoteCoord.x = Math.max(0, Math.min(remoteCoord.x, bitmap.getWidth()));
			remoteCoord.y = Math.max(0, Math.min(remoteCoord.y, bitmap.getHeight()));
		}
		
		try {
			LibFreeRDP.sendCursorEvent(session.getInstance(), remoteCoord.x, remoteCoord.y,
			                           Mouse.getLeftButtonEvent(this, down));
			
			if (sessionView != null) {
				Log.v(TAG, String.format("LeftClick: remote(%d,%d) [zoom=%.2f]", 
				                         remoteCoord.x, remoteCoord.y, sessionView.getZoom()));
			}
		} catch (Exception e) {
			Log.e(TAG, "Failed to send left click event", e);
		}
	}

	@Override public void onTouchPointerRightClick(Point remoteCoord, boolean down)
	{
		// 空指针检查
		if (remoteCoord == null || session == null) {
			Log.w(TAG, "onTouchPointerRightClick: null parameter");
			return;
		}
		
		// 边界检查
		if (bitmap != null && !bitmap.isRecycled())
		{
			remoteCoord.x = Math.max(0, Math.min(remoteCoord.x, bitmap.getWidth()));
			remoteCoord.y = Math.max(0, Math.min(remoteCoord.y, bitmap.getHeight()));
		}
		
		try {
			LibFreeRDP.sendCursorEvent(session.getInstance(), remoteCoord.x, remoteCoord.y,
			                           Mouse.getRightButtonEvent(this, down));
			
			if (sessionView != null) {
				Log.v(TAG, String.format("RightClick: remote(%d,%d) [zoom=%.2f]", 
				                         remoteCoord.x, remoteCoord.y, sessionView.getZoom()));
			}
		} catch (Exception e) {
			Log.e(TAG, "Failed to send right click event", e);
		}
	}

	@Override public void onTouchPointerMove(Point remoteCoord)
	{
		// 空指针检查 (移动事件频繁，静默失败)
		if (remoteCoord == null || session == null) {
			return;
		}
		
		// 边界检查
		if (bitmap != null && !bitmap.isRecycled())
		{
			remoteCoord.x = Math.max(0, Math.min(remoteCoord.x, bitmap.getWidth()));
			remoteCoord.y = Math.max(0, Math.min(remoteCoord.y, bitmap.getHeight()));
		}
		
		try {
			// Update remote cursor position
			if (sessionView != null)
			{
				sessionView.updateRemoteCursorPosition(remoteCoord.x, remoteCoord.y);
			}
			
			LibFreeRDP.sendCursorEvent(session.getInstance(), remoteCoord.x, remoteCoord.y, Mouse.getMoveEvent());

			if (ApplicationSettingsActivity.getAutoScrollTouchPointer(this) &&
			    !uiHandler.hasMessages(UIHandler.SCROLLING_REQUESTED))
			{
				Log.v(TAG, "Starting auto-scroll");
				uiHandler.sendEmptyMessageDelayed(UIHandler.SCROLLING_REQUESTED, SCROLLING_TIMEOUT);
			}
		} catch (Exception e) {
			// 移动事件频繁，不记录每个异常
		}
	}

	@Override public void onTouchPointerScroll(boolean down)
	{
		if (session == null) {
			return;
		}
		
		try {
			LibFreeRDP.sendCursorEvent(session.getInstance(), 0, 0, Mouse.getScrollEvent(this, down));
		} catch (Exception e) {
			Log.e(TAG, "Failed to send scroll event", e);
		}
	}

	@Override public void onTouchPointerToggleKeyboard()
	{
		showKeyboard(!sysKeyboardVisible, false);
	}

	@Override public void onTouchPointerToggleExtKeyboard()
	{
		showKeyboard(false, !extKeyboardVisible);
	}

	@Override public void onTouchPointerResetScrollZoom()
	{
		try {
			if (sessionView != null) {
				sessionView.setZoom(1.0f);
			}
			if (scrollView != null) {
				scrollView.scrollTo(0, 0);
			}
		} catch (Exception e) {
			Log.e(TAG, "Failed to reset scroll/zoom", e);
		}
	}

	@Override public boolean onGenericMotionEvent(MotionEvent e)
	{
		super.onGenericMotionEvent(e);
		
		if (e == null || session == null) {
			return false;
		}
		
		try {
			switch (e.getAction())
			{
				case MotionEvent.ACTION_SCROLL:
					final float vScroll = e.getAxisValue(MotionEvent.AXIS_VSCROLL);
					if (vScroll < 0)
					{
						LibFreeRDP.sendCursorEvent(session.getInstance(), 0, 0,
						                           Mouse.getScrollEvent(this, false));
					}
					if (vScroll > 0)
					{
						LibFreeRDP.sendCursorEvent(session.getInstance(), 0, 0,
						                           Mouse.getScrollEvent(this, true));
					}
					break;
			}
			return true;
		} catch (Exception ex) {
			Log.e(TAG, "Exception in onGenericMotionEvent", ex);
			return false;
		}
	}

	// ****************************************************************************
	// ClipboardManagerProxy.OnClipboardChangedListener
	@Override public void onClipboardChanged(String data)
	{
		Log.v(TAG, "onClipboardChanged: " + data);
		LibFreeRDP.sendClipboardData(session.getInstance(), data);
	}

	private class UIHandler extends Handler
	{

		public static final int REFRESH_SESSIONVIEW = 1;
		public static final int DISPLAY_TOAST = 2;
		public static final int HIDE_ZOOMCONTROLS = 3;
		public static final int SEND_MOVE_EVENT = 4;
		public static final int SHOW_DIALOG = 5;
		public static final int GRAPHICS_CHANGED = 6;
		public static final int SCROLLING_REQUESTED = 7;
		public static final int SHOW_ZOOMCONTROLS = 8;

		UIHandler()
		{
			super();
		}

		@Override public void handleMessage(Message msg)
		{
			switch (msg.what)
			{
				case GRAPHICS_CHANGED:
				{
					sessionView.onSurfaceChange(session);
					scrollView.requestLayout();
					break;
				}
				case REFRESH_SESSIONVIEW:
				{
					sessionView.invalidateRegion();
					break;
				}
				case DISPLAY_TOAST:
				{
					Toast errorToast = Toast.makeText(getApplicationContext(), msg.obj.toString(),
					                                  Toast.LENGTH_LONG);
					errorToast.show();
					break;
				}
				case HIDE_ZOOMCONTROLS:
				{
					if (zoomControls.isShown())
						zoomControls.hide();
					break;
				}
				case SHOW_ZOOMCONTROLS:
				{
					if (!zoomControls.isShown())
						zoomControls.show();

					break;
				}
			case SEND_MOVE_EVENT:
			{
				if (session != null) {
					try {
						LibFreeRDP.sendCursorEvent(session.getInstance(), msg.arg1, msg.arg2,
						                           Mouse.getMoveEvent());
					} catch (Exception e) {
						Log.e(TAG, "Failed to send delayed move event", e);
					}
				}
				break;
			}
				case SHOW_DIALOG:
				{
					// create and show the dialog
					((Dialog)msg.obj).show();
					break;
				}
				case SCROLLING_REQUESTED:
				{
					int scrollX = 0;
					int scrollY = 0;
					float[] pointerPos = touchPointerView.getPointerPosition();

					if (pointerPos[0] > (screen_width - touchPointerView.getPointerWidth()))
						scrollX = SCROLLING_DISTANCE;
					else if (pointerPos[0] < 0)
						scrollX = -SCROLLING_DISTANCE;

					if (pointerPos[1] > (screen_height - touchPointerView.getPointerHeight()))
						scrollY = SCROLLING_DISTANCE;
					else if (pointerPos[1] < 0)
						scrollY = -SCROLLING_DISTANCE;

					scrollView.scrollBy(scrollX, scrollY);

					// see if we reached the min/max scroll positions
					if (scrollView.getScrollX() == 0 ||
					    scrollView.getScrollX() == (sessionView.getWidth() - scrollView.getWidth()))
						scrollX = 0;
					if (scrollView.getScrollY() == 0 ||
					    scrollView.getScrollY() ==
					        (sessionView.getHeight() - scrollView.getHeight()))
						scrollY = 0;

					if (scrollX != 0 || scrollY != 0)
						uiHandler.sendEmptyMessageDelayed(SCROLLING_REQUESTED, SCROLLING_TIMEOUT);
					else
						Log.v(TAG, "Stopping auto-scroll");
					break;
				}
			}
		}
	}

	private class PinchZoomListener extends ScaleGestureDetector.SimpleOnScaleGestureListener
	{
		private float scaleFactor = 1.0f;

		@Override public boolean onScaleBegin(ScaleGestureDetector detector)
		{
			scrollView.setScrollEnabled(false);
			return true;
		}

		@Override public boolean onScale(ScaleGestureDetector detector)
		{

			// calc scale factor
			scaleFactor *= detector.getScaleFactor();
			scaleFactor = Math.max(SessionView.MIN_SCALE_FACTOR,
			                       Math.min(scaleFactor, SessionView.MAX_SCALE_FACTOR));
			sessionView.setZoom(scaleFactor);

			if (!sessionView.isAtMinZoom() && !sessionView.isAtMaxZoom())
			{
				// transform scroll origin to the new zoom space
				float transOriginX = scrollView.getScrollX() * detector.getScaleFactor();
				float transOriginY = scrollView.getScrollY() * detector.getScaleFactor();

				// transform center point to the zoomed space
				float transCenterX =
				    (scrollView.getScrollX() + detector.getFocusX()) * detector.getScaleFactor();
				float transCenterY =
				    (scrollView.getScrollY() + detector.getFocusY()) * detector.getScaleFactor();

				// scroll by the difference between the distance of the
				// transformed center/origin point and their old distance
				// (focusX/Y)
				scrollView.scrollBy((int)((transCenterX - transOriginX) - detector.getFocusX()),
				                    (int)((transCenterY - transOriginY) - detector.getFocusY()));
			}

			return true;
		}

		@Override public void onScaleEnd(ScaleGestureDetector de)
		{
			scrollView.setScrollEnabled(true);
		}
	}

	private class LibFreeRDPBroadcastReceiver extends BroadcastReceiver
	{
		@Override public void onReceive(Context context, Intent intent)
		{
			// still got a valid session?
			if (session == null)
				return;

			// is this event for the current session?
			if (session.getInstance() != intent.getExtras().getLong(GlobalApp.EVENT_PARAM, -1))
				return;

			switch (intent.getExtras().getInt(GlobalApp.EVENT_TYPE, -1))
			{
				case GlobalApp.FREERDP_EVENT_CONNECTION_SUCCESS:
					OnConnectionSuccess(context);
					break;

				case GlobalApp.FREERDP_EVENT_CONNECTION_FAILURE:
					OnConnectionFailure(context);
					break;
				case GlobalApp.FREERDP_EVENT_DISCONNECTED:
					OnDisconnected(context);
					break;
			}
		}

		private void OnConnectionSuccess(Context context)
		{
			Log.v(TAG, "OnConnectionSuccess");

		// Reset reconnection attempts on successful connection
		resetReconnectState();
		
		// 标记有活跃会话（用于服务自动重启）
		SharedPreferences.Editor editor = getSharedPreferences("rdp_state", MODE_PRIVATE).edit();
		editor.putBoolean("has_active_session", true);
		
		// 保存会话实例ID，供重启后恢复
		if (session != null) {
			editor.putLong("session_instance", session.getInstance());
			Log.i(TAG, "Saved session instance: " + session.getInstance());
		}
		
		editor.apply();
		
		// 重置服务重启计数
		com.freerdp.freerdpcore.application.ServiceRestartReceiver.resetRestartCount(context);

		// 注册网络监听器（按需注册，仅会话活跃时）
		registerNetworkReceiver();

			// bind session
			bindSession();

			if (progressDialog != null)
			{
				progressDialog.dismiss();
				progressDialog = null;
			}

			if (session.getBookmark() == null)
			{
				// Return immediately if we launch from URI
				return;
			}

			// add hostname to history if quick connect was used
			Bundle bundle = getIntent().getExtras();
			if (bundle != null && bundle.containsKey(PARAM_CONNECTION_REFERENCE))
			{
				if (ConnectionReference.isHostnameReference(
				        bundle.getString(PARAM_CONNECTION_REFERENCE)))
				{
					assert session.getBookmark().getType() == BookmarkBase.TYPE_MANUAL;
					String item = session.getBookmark().<ManualBookmark>get().getHostname();
					if (!GlobalApp.getQuickConnectHistoryGateway().historyItemExists(item))
						GlobalApp.getQuickConnectHistoryGateway().addHistoryItem(item);
				}
			}
		}

	private void OnConnectionFailure(Context context)
	{
		Log.v(TAG, "OnConnectionFailure");

		// 获取错误信息
		String errorString = "";
		if (session != null) {
			errorString = LibFreeRDP.getLastErrorString(session.getInstance());
			Log.i(TAG, "🔍 断开原因检测: " + errorString);
		}

		// remove pending move events
		uiHandler.removeMessages(UIHandler.SEND_MOVE_EVENT);

		if (progressDialog != null)
		{
			progressDialog.dismiss();
			progressDialog = null;
		}

		// ❌ 手动断开 - 任何时候都不重连
		if (manualDisconnect || connectCancelledByUser) {
			Log.i(TAG, "❌ 手动断开 - 不重连");
			if (!connectCancelledByUser)
				uiHandler.sendMessage(
				    Message.obtain(null, UIHandler.DISPLAY_TOAST,
				                   getResources().getText(R.string.error_connection_failure)));
			closeSessionActivity(RESULT_CANCELED);
			return;
		}

		// 🎯 检测是否被踢出
		boolean isKickedOut = false;
		if (errorString != null && 
		    (errorString.contains("administrative tool") || errorString.contains("another session"))) {
			isKickedOut = true;
			Log.i(TAG, "✅ 检测到被踢出");
		}

	// 📌 如果是被踢出，检查是否勾选
	if (isKickedOut) {
		boolean autoReconnectEnabled = false;
		if (reconnectBookmark != null && reconnectBookmark.getId() > 0) {
			try {
				BookmarkBase latestBookmark = GlobalApp.getManualBookmarkGateway().findById(reconnectBookmark.getId());
				if (latestBookmark != null) {
					autoReconnectEnabled = latestBookmark.getAdvancedSettings().getAutoReconnectOnKick();
				}
			} catch (Exception e) {
				Log.e(TAG, "读取设置失败: " + e.getMessage());
			}
		}
		
		if (!autoReconnectEnabled) {
			// 未勾选 - 不重连，显示对话框（需要手动确认）
			Log.i(TAG, "❌ 被踢出且未勾选 - 不重连，显示对话框");
			uiHandler.post(new Runnable() {
				@Override
				public void run() {
					AlertDialog.Builder builder = new AlertDialog.Builder(SessionActivity.this);
					builder.setTitle(R.string.dialog_kicked_out_title);
					builder.setMessage(R.string.dialog_kicked_out_message);
					builder.setCancelable(false);
					builder.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
							closeSessionActivity(RESULT_CANCELED);
						}
					});
					builder.show();
				}
			});
			return;
		}
		
		// 已勾选 - 显示Toast（自动消失），然后重连
		Log.i(TAG, "✅ 被踢出但已勾选 - 显示Toast并尝试重连");
		uiHandler.sendMessage(
		    Message.obtain(null, UIHandler.DISPLAY_TOAST,
		                   getResources().getText(R.string.dialog_kicked_out_message)));
	} else {
		// 其他情况（网络断开等）- 始终重连
		Log.i(TAG, "✅ 网络断开或其他错误 - 始终重连");
	}

		// 🔄 执行重连逻辑
		if (reconnectBookmark != null && reconnectAttempts.get() < MAX_RECONNECT_ATTEMPTS)
		{
			attemptReconnect();
		}
		else
		{
			if (reconnectAttempts.get() >= MAX_RECONNECT_ATTEMPTS) {
				showReconnectFailedAndExit();
			} else {
				uiHandler.sendMessage(
				    Message.obtain(null, UIHandler.DISPLAY_TOAST,
				                   getResources().getText(R.string.error_connection_failure)));
				closeSessionActivity(RESULT_CANCELED);
			}
		}
	}

		private void OnDisconnected(Context context)
		{
			Log.v(TAG, "OnDisconnected");

			// remove pending move events
			uiHandler.removeMessages(UIHandler.SEND_MOVE_EVENT);

			if (progressDialog != null)
			{
				progressDialog.dismiss();
				progressDialog = null;
			}

			// Don't auto-reconnect if manual disconnect
			if (manualDisconnect) {
				Log.i(TAG, "Manual disconnect - skip auto-reconnect");
				session.setUIEventListener(null);
				closeSessionActivity(RESULT_OK);
				return;
			}

		// Check if auto-reconnect on kick is enabled
		// 重新从数据库加载最新设置，确保获取最新的 autoReconnectOnKick 值
		// 注意：只读取设置值，不更新 reconnectBookmark 对象
		Log.i(TAG, "OnDisconnected: ========== 开始检查是否重连 ==========");
		Log.i(TAG, "OnDisconnected: reconnectBookmark=" + (reconnectBookmark != null ? "not null" : "null"));
		if (reconnectBookmark != null) {
			Log.i(TAG, "OnDisconnected: reconnectBookmark.getId()=" + reconnectBookmark.getId());
			Log.i(TAG, "OnDisconnected: reconnectBookmark.getLabel()=" + reconnectBookmark.getLabel());
		}
		Log.i(TAG, "OnDisconnected: sessionRunning=" + sessionRunning);
		Log.i(TAG, "OnDisconnected: reconnectAttempts=" + reconnectAttempts.get());
		
		// 被踢出时的重连判断：必须从数据库读取最新值，如果读取失败，默认不重连（false）
		boolean autoReconnectEnabled = false;  // 默认不重连
		if (reconnectBookmark != null && reconnectBookmark.getId() > 0) {
			Log.i(TAG, "OnDisconnected: 缓存的 reconnectBookmark.autoReconnectOnKick=" + reconnectBookmark.getAdvancedSettings().getAutoReconnectOnKick());
			try {
				// 强制从数据库重新加载 bookmark 以获取最新设置
				BookmarkBase latestBookmark = GlobalApp.getManualBookmarkGateway().findById(reconnectBookmark.getId());
				if (latestBookmark != null) {
					autoReconnectEnabled = latestBookmark.getAdvancedSettings().getAutoReconnectOnKick();
					Log.i(TAG, "OnDisconnected: ✓ 从数据库重新加载成功 (ID=" + reconnectBookmark.getId() + ")");
					Log.i(TAG, "OnDisconnected: ✓ 数据库中的 autoReconnectOnKick=" + autoReconnectEnabled);
					Log.i(TAG, "OnDisconnected: ✓ 对比 - 缓存值=" + reconnectBookmark.getAdvancedSettings().getAutoReconnectOnKick() + ", 数据库值=" + autoReconnectEnabled);
				} else {
					// 从数据库加载失败，默认不重连（false）
					autoReconnectEnabled = false;
					Log.w(TAG, "OnDisconnected: ✗ 从数据库加载失败 (ID=" + reconnectBookmark.getId() + "), 默认不重连 (false)");
				}
			} catch (Exception e) {
				// 从数据库加载异常，默认不重连（false）
				autoReconnectEnabled = false;
				Log.e(TAG, "OnDisconnected: ✗ 从数据库加载异常: " + e.getMessage() + ", 默认不重连 (false)", e);
			}
		} else if (reconnectBookmark != null) {
			// 没有ID，无法从数据库读取，默认不重连（false）
			autoReconnectEnabled = false;
			Log.w(TAG, "OnDisconnected: reconnectBookmark 无ID，无法从数据库读取，默认不重连 (false)");
		} else {
			// reconnectBookmark 为 null，默认不重连（false）
			autoReconnectEnabled = false;
			Log.w(TAG, "OnDisconnected: reconnectBookmark 为 null，默认不重连 (false)");
		}

		Log.i(TAG, "OnDisconnected: 最终判断 - autoReconnectEnabled=" + autoReconnectEnabled);
		
		// 被踢出（OnDisconnected）时的重连逻辑：
		// 只有勾选了"被踢出后自动重连"才重连，否则直接退出
		if (!autoReconnectEnabled) {
			// 未勾选：不重连，直接退出
			Log.i(TAG, "OnDisconnected: ✗ 未勾选自动重连，直接关闭会话");
			session.setUIEventListener(null);
			closeSessionActivity(RESULT_OK);
			return;
		}
		
		// 已勾选：检查其他条件
		Log.i(TAG, "OnDisconnected: ✓ 已勾选自动重连，检查其他条件");
		Log.i(TAG, "OnDisconnected: sessionRunning=" + sessionRunning + 
		           ", reconnectBookmark=" + (reconnectBookmark != null) + 
		           ", reconnectAttempts=" + reconnectAttempts.get() + 
		           ", MAX=" + MAX_RECONNECT_ATTEMPTS);
		
		if (sessionRunning && reconnectBookmark != null && 
		    reconnectAttempts.get() < MAX_RECONNECT_ATTEMPTS)
		{
			Log.i(TAG, "OnDisconnected: ►►► 所有条件满足，开始重连！");
			attemptReconnect();
		}
		else
		{
			Log.i(TAG, "OnDisconnected: ►►► 其他条件不满足");
			// Max reconnect attempts reached, show failure dialog
			if (reconnectAttempts.get() >= MAX_RECONNECT_ATTEMPTS) {
				Log.i(TAG, "OnDisconnected: 达到最大重连次数，显示失败对话框");
				showReconnectFailedAndExit();
			} else {
				Log.i(TAG, "OnDisconnected: 其他原因不重连，关闭会话");
				session.setUIEventListener(null);
				closeSessionActivity(RESULT_OK);
			}
		}
		Log.i(TAG, "OnDisconnected: ========== 检查结束 ==========");
		}
	}
	
	// //////////////////////////////////////////////////////////////////////
	// Memory Management (ComponentCallbacks2)
	
	@Override
	public void onTrimMemory(int level)
	{
		super.onTrimMemory(level);
		
		Log.w(TAG, "onTrimMemory: level=" + level + " (" + getTrimLevelName(level) + ")");
		
		switch (level)
		{
			case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:
				// 🚨 Severe memory pressure - aggressive cleanup
				Log.e(TAG, "🚨 CRITICAL memory pressure - aggressive cleanup");
				handleMemoryPressure("critical");
				break;
				
			case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:
				// ⚠️ Medium memory pressure - moderate cleanup
				Log.w(TAG, "⚠️ LOW memory pressure - moderate cleanup");
				handleMemoryPressure("low");
				break;
				
			case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:
				// 📝 Light memory pressure
				Log.i(TAG, "📝 MODERATE memory pressure - light cleanup");
				handleMemoryPressure("moderate");
				break;
				
			case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:
				// UI not visible (background) - already handled by onPause
				Log.i(TAG, "UI hidden - onPause already handles this");
				break;
				
			case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:
			case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
				// App in background with extreme memory pressure
				Log.e(TAG, "BACKGROUND/COMPLETE - extreme pressure");
				handleMemoryPressure("critical");
				break;
		}
	}
	
	private void handleMemoryPressure(String level)
	{
		if (session == null || !sessionRunning) {
			Log.d(TAG, "handleMemoryPressure: no active session, skip");
			return;
		}
		
		Log.w(TAG, "handleMemoryPressure: " + level);
		
		switch (level)
		{
			case "critical":
				// 🚨 Critical: aggressive cleanup
				isInMemoryCriticalMode = true;
				
				// 1. Keepalive is already running with dynamic intervals (5s->10s->15s)
				// No need to change it as existing implementation is already efficient
				Log.w(TAG, "Critical: using existing dynamic keepalive");
				
				// 2. Confirm graphics decoding is disabled
				if (!isInForeground) {
					try {
						LibFreeRDP.setClientDecoding(session.getInstance(), false);
						Log.w(TAG, "Critical: graphics decoding confirmed disabled");
					} catch (Exception e) {
						Log.e(TAG, "Failed to disable graphics", e);
					}
				}
				
				// 3. Release non-critical UI resources
				releaseNonCriticalUIResources();
				
				// 4. Suggest GC
				System.gc();
				Log.e(TAG, "Critical memory pressure handled");
				break;
				
			case "low":
				// ⚠️ Low: moderate cleanup
				isInMemoryCriticalMode = true;
				
				// Release non-critical UI resources
				releaseNonCriticalUIResources();
				Log.w(TAG, "Low memory pressure handled");
				break;
				
			case "moderate":
				// 📝 Moderate: light cleanup
				
				// Only release cursor and invalid regions (keep keyboard resources)
				if (sessionView != null) {
					sessionView.releaseRemoteCursorBitmap();
					sessionView.clearInvalidRegions();
				}
				Log.i(TAG, "Moderate memory pressure handled");
				break;
		}
	}
	
	/**
	 * Release non-critical UI resources to free memory (memory optimization)
	 * Safe to call anytime - resources will be recreated as needed
	 * 
	 * ✅ SAFE to release:
	 *   - Remote cursor bitmap (sessionView)
	 *   - Invalid regions stack (sessionView)
	 *   - Keyboard resources (if hidden)
	 * 
	 * ❌ NEVER release:
	 *   - Main desktop bitmap (session.surface.getBitmap())
	 *   - RDP connection objects
	 */
	private void releaseNonCriticalUIResources()
	{
		Log.i(TAG, "releaseNonCriticalUIResources start");
		
		// 1. Release remote cursor bitmap
		if (sessionView != null) {
			sessionView.releaseRemoteCursorBitmap();
		}
		
	// 2. Clear invalid regions stack - 只在后台时清理，避免前台使用时闪屏
	if (sessionView != null && !isInForeground) {
		sessionView.clearInvalidRegions();
		Log.d(TAG, "Invalid regions cleared (background only)");
	}
		
		// 3. Release keyboard resources if hidden
		if (!sysKeyboardVisible && !extKeyboardVisible) {
			try {
				if (keyboardMapper != null) {
					keyboardMapper.reset(this);
				}
				Log.d(TAG, "Keyboard mapper reset");
			} catch (Exception e) {
				Log.w(TAG, "Failed to reset keyboard mapper", e);
			}
		}
		
		// 4. Hide SessionView to reduce rendering overhead (but NOT release bitmap)
		if (sessionView != null && !isInForeground) {
			sessionView.setVisibility(View.INVISIBLE);
			Log.d(TAG, "SessionView hidden (will restore on resume)");
		}
		
		Log.i(TAG, "releaseNonCriticalUIResources complete");
	}
	
	private String getTrimLevelName(int level)
	{
		switch (level)
		{
			case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL: return "RUNNING_CRITICAL";
			case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW: return "RUNNING_LOW";
			case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE: return "RUNNING_MODERATE";
			case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN: return "UI_HIDDEN";
			case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND: return "BACKGROUND";
			case ComponentCallbacks2.TRIM_MEMORY_MODERATE: return "MODERATE";
			case ComponentCallbacks2.TRIM_MEMORY_COMPLETE: return "COMPLETE";
			default: return "UNKNOWN(" + level + ")";
		}
	}
}
