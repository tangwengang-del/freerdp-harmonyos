package com.freerdp.freerdpcore.services;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;

import androidx.core.app.NotificationCompat;

import com.freerdp.freerdpcore.R;

/**
 * Foreground service to keep RDP connection alive in background
 * Ensures audio streaming continues even when app is in background or screen is locked
 * Also handles reconnection timer (stable even during screen lock on Xiaomi/Huawei devices)
 */
public class RdpAudioService extends Service {
    private static final String TAG = "RdpAudioService";
    private static final String CHANNEL_ID = "rdp_audio_channel";
    private static final int NOTIFICATION_ID = 1001;
    private static final long RECONNECT_CHECK_INTERVAL = 10000; // 10 seconds fixed interval
    
    private static RdpAudioService instance;
    private static boolean isRunning = false;
    
    // Reconnection timer (runs in foreground service, stable during screen lock)
    private Handler reconnectHandler;
    private Runnable reconnectCheckTask;
    
    // Callback interface for reconnection
    public interface ReconnectCallback {
        void onReconnectCheck();
    }
    private static ReconnectCallback reconnectCallback;

    @Override
    public void onCreate() {
        super.onCreate();
        Log.i(TAG, "RdpAudioService created");
        instance = this;
        
        // Initialize reconnect handler (runs on main looper, stable in foreground service)
        reconnectHandler = new Handler(Looper.getMainLooper());
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i(TAG, "RdpAudioService started");
        
        // Create notification channel (Android 8.0+)
        createNotificationChannel();
        
        // Build notification
        Notification notification = buildNotification();
        
        // Start as foreground service
        startForeground(NOTIFICATION_ID, notification);
        isRunning = true;
        
        // Start reconnection check loop (15 seconds interval)
        startReconnectCheckLoop();
        
        // Return START_STICKY to ensure service is restarted if killed
        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        Log.i(TAG, "RdpAudioService destroyed");
        
        // Stop reconnection check loop
        stopReconnectCheckLoop();
        
        isRunning = false;
        instance = null;
        super.onDestroy();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null; // We don't provide binding
    }

    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                CHANNEL_ID,
                "远程桌面音频",
                NotificationManager.IMPORTANCE_LOW // Low importance = no sound/vibration
            );
            channel.setDescription("保持远程桌面连接以接收音频");
            channel.setShowBadge(false);
            
            NotificationManager manager = getSystemService(NotificationManager.class);
            if (manager != null) {
                manager.createNotificationChannel(channel);
            }
        }
    }

    private Notification buildNotification() {
        // Intent to return to existing SessionActivity (not create new one)
        Intent notificationIntent = new Intent(this, com.freerdp.freerdpcore.presentation.SessionActivity.class);
        // Critical: bring existing instance to front, don't create new one
        notificationIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        
        PendingIntent pendingIntent = PendingIntent.getActivity(
            this, 
            0, 
            notificationIntent,
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.M 
                ? PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT
                : PendingIntent.FLAG_UPDATE_CURRENT
        );

        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("远程桌面音频连接")
            .setContentText("点击返回远程桌面")
            .setSmallIcon(R.drawable.icon_launcher_freerdp) // Use FreeRDP app icon
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_LOW) // Low priority = minimal intrusion
            .setOngoing(true) // Cannot be dismissed by user (keeps connection alive)
            .setShowWhen(false)
            .setAutoCancel(false); // Don't auto-cancel when clicked

        return builder.build();
    }

    /**
     * Start the foreground service
     */
    public static void start(Context context) {
        if (isRunning) {
            Log.d(TAG, "Service already running, skip start");
            return;
        }
        
        Intent intent = new Intent(context, RdpAudioService.class);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            context.startForegroundService(intent);
        } else {
            context.startService(intent);
        }
        Log.i(TAG, "Service start requested");
    }

    /**
     * Stop the foreground service
     */
    public static void stop(Context context) {
        if (!isRunning) {
            Log.d(TAG, "Service not running, skip stop");
            return;
        }
        
        Intent intent = new Intent(context, RdpAudioService.class);
        context.stopService(intent);
        Log.i(TAG, "Service stop requested");
    }

    /**
     * Check if service is running
     */
    public static boolean isRunning() {
        return isRunning;
    }

    /**
     * Update notification content (e.g., to show connection status)
     */
    public static void updateNotification(Context context, String contentText) {
        if (!isRunning || instance == null) {
            Log.d(TAG, "Service not running, cannot update notification");
            return;
        }
        
        instance.updateNotificationContent(contentText);
    }

    private void updateNotificationContent(String contentText) {
        Notification notification = buildNotificationWithText(contentText);
        NotificationManager manager = getSystemService(NotificationManager.class);
        if (manager != null) {
            manager.notify(NOTIFICATION_ID, notification);
            Log.d(TAG, "Notification updated: " + contentText);
        }
    }

    private Notification buildNotificationWithText(String contentText) {
        Intent notificationIntent = new Intent(this, com.freerdp.freerdpcore.presentation.SessionActivity.class);
        // Critical: bring existing instance to front, don't create new one
        notificationIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        
        PendingIntent pendingIntent = PendingIntent.getActivity(
            this, 
            0, 
            notificationIntent,
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.M 
                ? PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT
                : PendingIntent.FLAG_UPDATE_CURRENT
        );

        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("远程桌面音频连接")
            .setContentText(contentText)
            .setSmallIcon(R.drawable.icon_launcher_freerdp) // Use FreeRDP app icon
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setOngoing(true)
            .setShowWhen(false)
            .setAutoCancel(false);

        return builder.build();
    }
    
    /**
     * Start reconnection check loop (15 seconds interval)
     * This runs in foreground service, stable even during screen lock
     */
    private void startReconnectCheckLoop() {
        if (reconnectCheckTask != null) {
            Log.d(TAG, "Reconnect check loop already running");
            return;
        }
        
        reconnectCheckTask = new Runnable() {
            @Override
            public void run() {
                Log.i(TAG, "Reconnect check triggered (10s interval, foreground service)");
                
                // Notify SessionActivity to check and perform reconnection
                if (reconnectCallback != null) {
                    reconnectCallback.onReconnectCheck();
                } else {
                    Log.d(TAG, "No reconnect callback registered");
                }
                
                // Schedule next check
                if (reconnectHandler != null && reconnectCheckTask != null) {
                    reconnectHandler.postDelayed(this, RECONNECT_CHECK_INTERVAL);
                }
            }
        };
        
        // Start the loop
        reconnectHandler.postDelayed(reconnectCheckTask, RECONNECT_CHECK_INTERVAL);
        Log.i(TAG, "Reconnect check loop started (10 seconds interval)");
    }
    
    /**
     * Stop reconnection check loop
     */
    private void stopReconnectCheckLoop() {
        if (reconnectHandler != null && reconnectCheckTask != null) {
            reconnectHandler.removeCallbacks(reconnectCheckTask);
            reconnectCheckTask = null;
            Log.i(TAG, "Reconnect check loop stopped");
        }
    }
    
    /**
     * Set reconnection callback
     */
    public static void setReconnectCallback(ReconnectCallback callback) {
        reconnectCallback = callback;
        Log.i(TAG, "Reconnect callback registered: " + (callback != null));
    }
    
    /**
     * Clear reconnection callback
     */
    public static void clearReconnectCallback() {
        reconnectCallback = null;
        Log.i(TAG, "Reconnect callback cleared");
    }
}

