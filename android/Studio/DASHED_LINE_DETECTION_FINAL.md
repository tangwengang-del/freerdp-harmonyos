# 虚实线检测 - 最终版本

## 更新日期
2025-12-27 (最终简化版)

## 虚实线规则

**用户实际虚实线模式**：`25px实 - 5px空 - 5px实 - 5px空`
- 实线部分最长：25px
- 因此设定安全阈值：**超过30px的连续红/绿线段 = 实线，要排除**

## 检测逻辑（极简3条件）

```
1. ✅ 颜色：红色或绿色
2. ✅ 有断开：至少1个断开（不是连续实线）
3. ✅ 实线段长度：最长线段 <= 30px（超过就是实线）
```

## 核心代码

```java
private boolean hasLongShortPattern(int[] pixels)
{
    // 分析段序列
    List<Segment> segments = 分析段(pixels);
    
    // 统计
    int lineSegmentCount = 0;  // 红/绿线段数
    int gapCount = 0;          // 断开数
    int maxLineLength = 0;     // 最长线段
    
    for (Segment seg : segments)
    {
        if (seg.isDark) {  // 红/绿线段
            lineSegmentCount++;
            maxLineLength = Math.max(maxLineLength, seg.length);
        }
        else {  // 断开
            gapCount++;
        }
    }
    
    // 判断
    return (lineSegmentCount >= 2) &&  // 至少2个线段
           (gapCount >= 1) &&          // 至少1个断开
           (maxLineLength <= 30);      // 最长线段不超过30px
}
```

## 检测范围

**触发时机**：松开鼠标左键/中键后立即执行（无延迟）

**【第一步】快速预扫描：**
- 垂直范围：Y ± 4px（共9行）
- 水平范围：X ± 5px（共10px）
- 扫描像素：90像素
- 检测目标：是否有红/绿像素

**【第二步】详细判定：**
- 垂直范围：Y ± 2px（共5行）
- 水平范围：X ± 100px（共200px）
- 扫描像素：1000像素
- 检测目标：虚实线模式判定

## 判断条件详解

### 条件1：颜色过滤
```java
boolean isLime = (g > 180) && (r < 120) && (b < 120);  // 绿色
boolean isRed = (r > 180) && (g < 120) && (b < 120);   // 红色
```
**效果**：只检测红/绿色线条，排除所有其它颜色

### 条件2：有断开
```java
gapCount >= 1
```
**效果**：
- ✅ 虚实线：有断开 → 通过
- ❌ 实线：无断开 → 排除

### 条件3：最长线段 <= 30px
```java
maxLineLength <= 30
```
**效果**：
- ✅ 虚实线：最长25px → 通过
- ❌ 实线：连续超过30px → 排除

## 为什么是30px？

根据虚实线规则：
```
25px实 - 5px空 - 5px实 - 5px空 - ...
```

- 实线部分最长：**25px**
- 设置安全阈值：**30px**
- 任何超过30px的连续红/绿段 = 实线

## 完整流程

```
1. 用户松开鼠标左键/中键
   ↓
2. 立即执行两步检测（无延迟）
   ↓
【第一步：快速预扫描】
3. 扫描 Y±4px 范围（9行）× 左右5px（10px）= 90像素
   ↓
4. 检测红/绿像素？
   NO → 结束（快11倍）
   YES → 记录红绿线Y坐标，进入第二步
   ↓
【第二步：详细判定】
5. 扫描 Y±2px 范围（5行）× 左右100px（200px）= 1000像素
   ↓
6. 颜色过滤：只保留红/绿像素
   ↓
7. 分析段序列：线段-断开-线段-断开...
   ↓
8. 统计：
   - 线段数
   - 断开数
   - 最长线段长度
   ↓
9. 判断：
   线段 >= 2？
   断开 >= 2？
   最长线段 <= 30px？
   ↓
   全部满足 → ✓ 虚实线检测成功！
   ↓
10. 自动移动指针对齐虚实线
   ↓
11. 指针变红，等待拖动
```

## 与之前版本的对比

| 特性 | 复杂版 | 最终版 |
|------|--------|--------|
| 颜色检测 | 红/绿 | 红/绿 |
| 长短模式 | 需要检查长段6-15px、短段2-5px | **不需要** |
| 模式数量 | 至少2组 | **不需要** |
| 断开检测 | 至少2个 | **至少1个** |
| 干净断开 | 需要检查断开处无干扰 | **不需要** |
| 垂直验证 | 需要检查上下11行 | **不需要** |
| **新增** | - | **最长线段 <= 30px** |

## 调试日志

启用DEBUG查看详细信息：
```java
private static final boolean DEBUG = true;
```

日志输出示例：
- `✓ 虚实线检测成功: 3个线段, 2个断开, 最长线段=25px`
- `✗ 检测失败: 线段=1, 断开=0, 最长线段=80px (超过30px排除)`

## 参数调整指南

### 1. 调整最长线段阈值

如果你的虚实线规则不同，可以调整：

```java
// 当前：最长30px
boolean hasPattern = ... && (maxLineLength <= 30);

// 如果实线部分更长（如40px实）：
boolean hasPattern = ... && (maxLineLength <= 45);

// 如果实线部分更短（如15px实）：
boolean hasPattern = ... && (maxLineLength <= 20);
```

**建议**：设置为实际最长线段 + 5px 的安全余量

### 2. 调整颜色阈值

如果检测不到虚实线：

```java
// 放宽阈值
boolean isLime = (g > 150) && (r < 140) && (b < 140);
boolean isRed = (r > 150) && (g < 140) && (b < 140);
```

如果误检测太多：

```java
// 收紧阈值
boolean isLime = (g > 200) && (r < 100) && (b < 100);
boolean isRed = (r > 200) && (g < 100) && (b < 100);
```

### 3. 调整最少线段数

```java
// 当前：至少2个线段
return (lineSegmentCount >= 2) && ...

// 更严格（减少误判）：
return (lineSegmentCount >= 3) && ...

// 更宽松：
return (lineSegmentCount >= 1) && ...
```

## 优势

1. **极简**：只有3个条件，逻辑清晰
2. **准确**：基于实际虚实线规则（25px实线）
3. **快速**：减少了80%的检查
4. **鲁棒**：颜色过滤 + 长度限制，双重保障
5. **易调**：只需调整1个参数（30px）

## 测试建议

1. 在虚实线上静止 → 应自动对齐并变红
2. 在实线上静止 → 不应触发（超过30px）
3. 在其它颜色线上静止 → 不应触发（颜色过滤）
4. 快速移动 → 不应卡顿

## 总结

**核心思想**：根据虚实线的实际规则（25px实-5px空-5px实-5px空）来设定检测条件。

**关键改进**：添加"最长线段 <= 30px"条件，精准排除实线。

**检测公式**：
```
虚实线 = 红/绿色 && 有断开 && 最长线段≤30px
```

简单、准确、高效！


